<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="葆宁">


    
    


<meta name="description" content="Stay Hungry,Stay Foolish！">
<meta property="og:type" content="website">
<meta property="og:title" content="geek_wuyu">
<meta property="og:url" content="https://github.com/michaelwuyu/michaelwuyu.github.io.git/index.html">
<meta property="og:site_name" content="geek_wuyu">
<meta property="og:description" content="Stay Hungry,Stay Foolish！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="geek_wuyu">
<meta name="twitter:description" content="Stay Hungry,Stay Foolish！">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="geek_wuyu" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>geek_wuyu</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/bn.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">葆宁</a></h1>
        </hgroup>

        
        <p class="header-subtitle">我怀念的是无言感动...</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa 北京大学" href="https://pku.edu.cn" title="北京大学"></a>
                            
                                <a class="fa 新浪微博" href="https://weibo.com/3042489123/" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/michaelwuyu" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 微信公众号" href="/img/WX.jpg" title="微信公众号"></a>
                            
                                <a class="fa CSDN" href="https://www.csdn.net/" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IT/">IT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IT互联网/">IT互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pku/">pku</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/互联网/">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人工智能/">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安娜/">安娜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/芯片/">芯片</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注Java开发&amp;大数据挖掘</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">葆宁</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/bn.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">葆宁</a></h1>
            </hgroup>
            
            <p class="header-subtitle">我怀念的是无言感动...</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa 北京大学" target="_blank" href="https://pku.edu.cn" title="北京大学"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="https://weibo.com/3042489123/" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/michaelwuyu" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 微信公众号" target="_blank" href="/img/WX.jpg" title="微信公众号"></a>
                            
                                <a class="fa CSDN" target="_blank" href="https://www.csdn.net/" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap">
  
    <article id="post-纸短情深" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/07/纸短情深/" class="article-date">
      <time datetime="2019-03-07T09:13:14.000Z" itemprop="datePublished">2019-03-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/07/纸短情深/">Refrain</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/images/5a9.gif" alt="&quot;安娜”"><br> 亲爱的，女生节快乐！<br>给我一首轻音乐的时间，<br>你来慢慢欣赏，<br>这封不算常规情书的情书。<br>至少它有名字—&gt;<br>Refrain<br>第一次点题。<br> <blockquote class="blockquote-center"><br>       <embed src="//music.163.com/style/swf/widget.swf?sid=22712173&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all"><br></blockquote><br>微信不能撤回2分钟前发的消息，<br>我喜欢了你十年，<br>又怎能,<br>轻易撤销？<br>—题外记<br>我就像一根火柴，<br>感觉快到了燃尽的终点啦！<br>2019.3.21 北京<br>—绝笔<br>我们合照美美哒！！<br><img src="/images/723.jpg" alt="&quot;安娜”"><br>下面是几张截图，<br>回忆杀！<br>这就是那个，<br>印象深刻 ，<br>彻夜无眠的晚上。<br>还有一个晚上，<br>就是去年，<br>我来北京考试，<br>单曲，<br>听了一整夜《钟无艳》。<br><img src="/images/311.jpg" alt="&quot;安娜”"><br>钱钟书的至理名言~<br>我的理解是，<br>如果你喜欢一个人，<br>你就应该把自己的葡萄给ta，<br>笑着说：<br>我不喜欢吃这个。<br><img src="/images/312.jpg" alt="&quot;安娜”"><br>如果我死了，<br>要选择一本书陪葬。<br>就是它了！<br><img src="/images/313.jpg" alt="&quot;安娜”"><br>520还需要说什么呢？<br><img src="/images/315.jpg" alt="&quot;安娜”"><br>纪念分手2周年~<br><img src="/images/316.jpg" alt="&quot;安娜”"><br>这过路人是谁？<br>我就不明说了。<br><img src="/images/319.jpg" alt="&quot;安娜”"><br>你说的用烂了的诗句！<br>我还偏偏最喜欢。<br>去东北时，<br>见过了孟姜，<br>见过了沧海。<br>所以曾经，<br>也算说了实话。<br>沧海月明珠有泪，<br>蓝田日暖钰生烟。<br><img src="/images/320.jpg" alt="&quot;安娜”"><br>可惜断了，<br>止于1825天！<br><img src="/images/321.jpg" alt="&quot;安娜”"><br>又是平凡，<br>只要平凡。<br>不过这本书，<br>是普及精简版。<br>我都没舍得给自己，<br>买线装上中下三册。<br><img src="/images/323.jpg" alt="&quot;安娜”"><br>自从2015年，<br>愚人节之后，<br>qq空间，<br>再也没发过说说。<br><img src="/images/324.jpg" alt="&quot;安娜”"><br>要毕业了，<br>想到很多事，<br>没有机会做，<br>只能留下，<br>遗憾。<br>此处，<br>第二次点题。<br><img src="/images/326.jpg" alt="&quot;安娜”"></p>
<hr>
<p>关于：<br>一纸&lt;情书&gt;<br>我觉得做的，<br>远比我写的，<br>更有说服力。<br>不过，<br>存在<br>自然有必要的价值。<br>三三两两，<br>遗迹<br>全在历史签名中夹着呢。<br>琢磨着,<br>亲手，<br>摘抄部分,<br>表示真实，<br>诚挚，<br>只要你开心，<br>我无所谓。<br>你说你吃了饭看，<br>可我到现在，<br>晚饭都没吃！<br><img src="/images/331.jpg" alt="&quot;安娜”"><br><img src="/images/330.jpg" alt="&quot;安娜”"><br><img src="/images/329.jpg" alt="&quot;安娜”"></p>
<p>回顾过去六年来，<br>心路历程，<br>很多感悟，<br>被时光打磨，<br>已经没那么深刻了。<br>现在觉得那个时候，<br>自己太傻了。<br>现在来看这些文字，<br>甚至矫情，<br>不习惯。<br>明知道，<br>破镜难圆，<br>前方是烈火，<br>却还是义无反顾，<br>那么把自己燃烧起来，<br>也许会变好吧？<br>于是葆宁(burning)，<br>遍用到现在…<br>你看<br>签名的时间间隔，<br>也很有意思，<br>前几年，<br>一月一次，<br>几乎固定，<br>问候招呼。<br>后几年，<br>几乎无交集了，<br>所以时间跨度就大了。<br>然而，<br>又有什么关系呢？<br>其实忘了给你说：<br>在最单相思的时候，<br>我经常翻你的qq签名，<br>甚至微博，<br>甚至唱吧，<br>甚至…</p>
<hr>
<p>张钰珠：<br>我爱你！forever！<br>这封情书，<br>不知道你喜欢不喜欢？<br>里面夹了承诺书，<br>把你一个我的“把柄”。<br>不过，<br>真的很花心血。<br>我想了很久，<br>情书的名字：<br>refrain，克制。<br>喜欢，就是放肆。<br>爱，就是克制。<br>也就是这个背景音乐，<br>时长8分52秒！<br>除了“克制，抑制”，<br>还有一个含义是“重复”，<br>如同这首曲子，<br>主旋律的多次重复，<br>将长度拉到了8分多钟，<br>每当觉得要结束时，<br>却又再次从头来了一遍，<br>感觉就好像一段难以放弃的感情，<br>想要忘记，<br>却又再次想起，<br>想要忘记，<br>却又再次想起，<br>想要忘记，<br>却又再次想起…<br>如此循环往复，<br>心痛不已，<br>无法自拔。<br>音乐散了，<br>可故事刚才开始…<br>encore une fois!<br>新的旅程，<br>还等着我们呢。<br>我希望，<br>这次旅程时长是，<br>一辈子！<br>2019年3月7日夜<br>吴葆宁<br>北京</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/安娜/">安娜</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安娜/">安娜</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pku" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/14/pku/" class="article-date">
      <time datetime="2018-09-14T15:24:54.000Z" itemprop="datePublished">2018-09-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/14/pku/">初见燕园</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/images/221.jpg" alt="&quot;pku”"><br><img src="/images/223.jpg" alt="&quot;pku”"><br><img src="/images/224.jpg" alt="&quot;pku”"><br><img src="/images/228.jpg" alt="&quot;pku”"><br><img src="/images/230.jpg" alt="&quot;pku”"><br>2018年9月14日 北京大学校本部</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/pku/">pku</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pku/">pku</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-软件项目开发流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/05/软件项目开发流程/" class="article-date">
      <time datetime="2018-06-05T03:04:54.000Z" itemprop="datePublished">2018-06-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/05/软件项目开发流程/">软件项目开发流程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/images/187.jpg" alt="&quot;AI”"></p>
<p>软件项目开发流程<br>  一：需求调研分析<br>     1相关系统分析员向用户初步了解需求，然后用word列出要开发的系统的大功能模块，每个大功能模块有哪些小功能模块，对于有些需求比较明确相关的界面时，在这一步里面可以初步定义好少量的界面。</p>
<p>2 系统分析员深入了解和分析需求，根据自己的经验和需求用WORD或相关的工具再做出一份文档系统的功能需求文档。这次的文档会清楚列出系统大致的大功能模块，大功能模块有哪些小功能模块，并且还列出相关的界面和界面功能。</p>
<p>3 系统分析员向用户再次确认需求。</p>
<p>  二：概要设计<br>    首先，开发者需要对软件系统进行概要设计，即系统设计。概要设计需要对软件系统的设计进行考虑，包括系统的基本处理流程、系统的组织结构、模块划分、功能分配、接口设计、运行设计、数据结构设计和出错处理设计等，为软件的详细设计提供基础。</p>
<p>  三：详细设计<br>    在概要设计的基础上，开发者需要进行软件系统的详细设计。在详细设计中，描述实 现具体模块所涉及到的主要算法、数据结构、类的层次结构及调用关系，需要说明软件系统各个层次中的每一个程序(每个模块或子程序)的设计考虑，以便进行编码和测试。应当保证软件的需求完全分配给整个软件。详细设计应当足够详细，能够根据详细设计报告进行编码。</p>
<p>  四：编码<br>    在软件编码阶段，开发者根据《软件系统详细设计报告》中对数据结构、算法分析和模块实现等方面的设计要求，开始具体的编写程序工作，分别实现各模块的功能，从而实现对目标系统的功能、性能、接口、界面等方面的要求。　</p>
<p>  五：测试<br>    测试编写好的系统。交给用户使用，用户使用后一个一个的确认每个功能。</p>
<p>  六：软件交付准备<br>    在软件测试证明软件达到要求后，软件开发者应向用户提交开发的目标安装程序、数据库的数据字典、《用户安装手册》、《用户使用指南》、需求报告、设计报告、测试报告等双方合同约定的产物。<br>    （《用户安装手册》应详细介绍安装软件对运行环境的要求、安装软件的定义和内容、在客户端、服务器端及中间件的具体安装步骤、安装后的系统配置。《用户使用指南》应包括软件各项功能的使用流程、操作步骤、相应业务介绍、特殊提示和注意事项等方面的内容，在需要时还应举例说明。）</p>
<p>  七：验收<br>    用户验收。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/IT/">IT</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IT/">IT</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-编程语言" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/01/编程语言/" class="article-date">
      <time datetime="2018-06-01T06:04:54.000Z" itemprop="datePublished">2018-06-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/01/编程语言/">各主流编程语言对比</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/images/187.jpg" alt="&quot;AI”"></p>
<p>PYTHON<br>特点：面向对象、解释型<br>主要用途：</p>
<ol>
<li>图形处理：有PIL、Tkinter等图形库支持，能方便进行图形处理。</li>
<li>数学处理：NumPy扩展提供大量与许多标准数学库的接口。</li>
<li>文本处理：python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。</li>
<li>数据库编程：程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，MySQL、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的SQL环境。</li>
<li>网络编程：提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。很多大规模软件开发计划例如Zope，Mnet 及BitTorrent. Google都在广泛地使用它。</li>
<li>Web编程：应用的开发语言，支持最新的XML技术。</li>
<li>多媒体应用：Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。</li>
<li>pymo引擎：PYMO全称为python memories off，是一款运行于Symbian S60V3,Symbian3,S60V5, Symbian3, Android系统上的AVG游戏引擎。因其基于python2.0平台开发，并且适用于创建秋之回忆（memories off）风格的AVG游戏，故命名为PYMO。</li>
<li>黑客编程：python有一个hack的库,内置了你熟悉的或不熟悉的函数，但是缺少成就感。</li>
</ol>
<p>优点：</p>
<ol>
<li>简单：PYTHON是一种代表简单主义思想的语言。阅读一个良好的PYTHON程序就感觉像是在读英语一样。它使你能够专注于解决问题而不是去搞明白语言本身。</li>
<li>易学：PYTHON极其容易上手，因为PYTHON有极其简单的说明文档。</li>
<li>速度快：PYTHON 的底层是用 C 语言写的，很多标准库和第三方库也都是用 C 写的，运行速度非常快。</li>
<li>免费、开源：PYTHON是FLOSS（自由/开放源码软件）之一。使用者可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。</li>
<li>高层语言：用PYTHON语言编写程序的时候无需考虑诸如如何管理你的程序使用的内存一类的底层细节。</li>
<li>可移植性：由于它的开源本质，PYTHON已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。这些平台包括LINUX、WINDOWS、FREEBSD、MACINTOSH、SOLARIS、OS/2、AMIGA、AROS、AS/400、BEOS、OS/390、Z/OS、PALM OS、QNX、VMS、PSION、ACOM RISC OS、VXWORKS、PLAYSTATION、SHARP ZAURUS、WINDOWS CE、POCKETPC、SYMBIAN以及GOOGLE基于LINUX开发的ANDROID平台。</li>
<li>解释性：一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。</li>
<li>运行程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而PYTHON语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。</li>
<li>在计算机内部，PYTHON解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。这使得使用PYTHON更加简单。也使得PYTHON程序更加易于移植。</li>
<li>面向对象：PYTHON既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。</li>
<li>可扩展性：如果需要一段关键代码运行得更快或者希望某些算法不公开，可以部分程序用C或C++编写，然后在PYTHON程序中使用它们。</li>
<li>可嵌入性：可以把PYTHON嵌入C/C++程序，从而向程序用户提供脚本功能。</li>
<li>丰富的库：PYTHON标准库确实很庞大。它可以帮助处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、TK和其他与系统有关的操作。这被称作PYTHON的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如WXPYTHON、TWISTED和PYTHON图像库等等。</li>
<li>规范的代码：PYTHON采用强制缩进的方式使得代码具有较好可读性。而PYTHON语言写的程序不需要编译成二进制代码。<br>缺点</li>
<li>单行语句和命令行输出问题：很多时候不能将程序连写成一行，如IMPORT SYS;FOR I IN SYS.PATH:PRINT I。而PERL和AWK就无此限制，可以较为方便的在SHELL下完成简单程序，不需要如PYTHON一样，必须将程序写入一个.PY文件。</li>
<li>独特的语法</li>
<li>这也许不应该被称为局限，但是它用缩进来区分语句关系的方式还是给很多初学者带来了困惑。即便是很有经验的PYTHON程序员，也可能陷入陷阱当中。最常见的情况是TAB和空格的混用会导致错误，而这是用肉眼无法分别的。</li>
<li>运行速度慢：这里是指与C和C++相比。<br>C<br>主要用途：<br>优点：<br>缺点<br>C++<br>特点：<br>C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。<br>主要用途：<br>系统开发，引擎开发</li>
<li>C++设计成静态类型、和C同样高效且可移植的多用途程序设计语言。</li>
<li>C++设计直接的和广泛的支持多种程序设计风格（程序化程序设计、资料抽象化、面向对象程序设计、泛型程序设计）。</li>
<li>C++设计无需复杂的程序设计环境。</li>
<li>C++语言灵活，运算符的数据结构丰富、具有结构化控制语句、程序执行效率高，而且同时具有高级语言与汇编语言的优点，与其它语言相比 ，可以直接访问物理地址，与汇编语言相比又具有良好的可读性和可移植性。<br>缺点：<br>C++由于语言本身复杂。C++的编译系统受到C++的复杂性的影响，非常难于编写，即使能够使用的编译器如果存在问题，可能难于被发现。[<br>C#<br>特点：<br>面向对象的、运行于.NET FRAMEWORK之上，面向对象<br>主要用途：<br>快速地编写各种基于MICROSOFT .NET平台的应用程序，MICROSOFT .NET提供了一系列的工具和服务来最大程度地开发利用计算与通讯领域。<br>优点：</li>
<li>更先进的语法体系</li>
<li>强大的周边<br>缺点</li>
<li>没有考虑代码量</li>
<li>这是一个产品<br>HTML<br>主要用途：<br>优点：<br>缺点<br>PHP<br>特点：<br>通用开源脚本语言</li>
</ol>
<p>主要用途：<br>WEB开发领域<br>优点：</p>
<ol>
<li>开放的源代码</li>
<li>免费性</li>
<li>快捷性</li>
<li>跨平台性强</li>
<li>效率高</li>
<li>图像处理</li>
<li>专业专注<br>缺点</li>
<li>对递归的不良支持</li>
<li>并非线程安全</li>
<li>因商业应用而残废</li>
<li>没有命名空间</li>
<li>不标准的日期格式字符</li>
<li>混乱的许可证</li>
<li>不一致的函数命名规则<br>JAVA<br>特点：<br>JAVA是一种可以撰写跨平台应用软件的面向对象的程序设计语言。JAVA 技术具有卓越的通用性、高效性、平台移植性和安全性<br>主要用途：<br>WEB浏览器、网络应用系统。<br>优点：<br>1． 简单性：风格类似于C++，JAVA摒弃了C++中容易引发程序错误的地方，如指针和内存管理。<br>2． 面向对象：JAVA是一种完全面向对象语言。从这点来看，JAVA类似于SMALLTALK，但其特性、尤其是适用于分布式计算环境的特性远远超越了SMALLTALK。<br>3． 分布式：JAVA包括一个支持HTTP和FTP等基于TCP/IP协议的子库。因此，JAVA应用程序可凭借URL打开并访问网络上的对象，其访问方式与访问本地文件系统几乎完全相同。<br>4． 健壮：JAVA致力于检查程序在编译和运行时的错误。类型检查帮助检查出许多开发早期出现的错误。JAVA自己操纵内存减少了内存出错的可能性。<br>5． 结构中立：JAVA将程序编译成一种结构中立的中间文件格式。只要有JAVA运行系统的机器都执行这种中间代码。这种中间语言被设计在虚拟机上运行，由机器相关的运行调试器实现执行。<br>6． 安全：<br>1）删除了香指针和手动释放内存等功能，避免了非法内存操作。<br>2）当JAVA用来创建浏览器时，语言功能和浏览器本身提供的功能结合起来。<br>JAVA在机器上执行前，要经过很多测试，它经过代码校验，检查代码段的格式，检测指针操作，对象操作是否过分以及试图改变一个对象的类型。<br>7． 可移植的：同体系结构无关的特性使得JAVA应用程序可以在配备JAVA解释器和运行环境的任何计算机系统上运行。任何JAVA代码会被解释成一种中间语言，然后通过不同机子的特定环境（如机器指令）运行程序。实现方便移植的特点。<br>8． 解释性。JAVA解释器能直接运行目标代码指令。链接程序通常比编译程序所需资源少。<br>9． 高性能。如果解释器速度不慢，JAVA可以在运行时直接将目标代码翻译成机器指令。SUN用直接解释器一秒钟内可调用300,000个过程。<br>10． 多线程：JAVA提供的多线程功能使得在一个程序里可同时执行多个小任务。多线程带来的更大好处是更好的交互性能和实时控制性能。<br>11． 动态：动态特性允许程序动态地装入运行过程中所需要的类。在运行时确定引用的好处是可以使用已被更新的类，而不必担心会影响原有的代码。如果程序连接了网络中另一系统中的某一类，该类的所有者也可以自由地对该类进行更新，而不会使任何引用该类的程序崩溃。<br>缺点</li>
<li>存在非对象的数据类型</li>
<li>不能够用一种描述方法来表达各种类（CLASS）</li>
<li>无法继承2个以上的类的装配<br>JAVASCRIPT<br>特点：<br>直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型<br>主要用途：</li>
<li>嵌入动态文本于HTML页面。[4] </li>
<li>对浏览器事件做出响应。[4] </li>
<li>读写HTML元素。[4] </li>
<li>在数据被提交到服务器之前验证数据。[4] </li>
<li>检测访客的浏览器信息。[4] </li>
<li>控制cookies，包括创建和修改等。[4] </li>
<li>基于Node.js技术进行服务器端编程。[</li>
</ol>
<p>优点：</p>
<ol>
<li>减少网络传输</li>
<li>方便地操纵HTML对象</li>
<li>支持分布式运算和处理<br>缺点：</li>
<li>不同浏览器支持程度不同</li>
<li>WEB安全性<br>框架介绍：<br>(1).JQUERY<br><1>.介绍<br>JQUERY 是一款同 PROTOTYPE 一样优秀 JS 开发库类，特别是对 CSS 和 XPATH 的支持，使我们写 JS 变得更加方便！如果你不是个 JS 高手又想写出优秀的 JS 效果，那么 JQUERY 可以帮你达到目的！并且简介的语法和高的效率一直是JQUERY追求的目标。<br><2>.优点：注重简介和高效，JS 效果有 YUI-EXT 的选择，因为 YUI-EXT 重用了很多 JQUERY 的函数<br><3>.缺点：据说太嫩，历史不悠久。</3></2></1></li>
</ol>
<p>(2).EXT</p>
<p><1>.介绍<br>基于 YAHOO UI 的扩展包 YUI-EXT 是具有 CS 风格的 WEB 用户界面组件，能实现复杂的 LAYOUT 布局，界面效果可以和 BACKBASE 媲美，而且使用纯 JAVASCRIPT 代码开发。真正的可编辑的表格 EDIT GRID，支持 XML 和 JSON 数据类型，直接可以迁入 GRID。许多组件实现了对数据源的支持，例如动态的布局，可编辑的表格控件，动态加载的 TREE 控件、动态拖拽效果等等。从 1.0 BETA 版开始同 JQUERY 合作，推出基于 JQUERY 的 EXT 1.0，提供了更多有趣的功能。</1></p>
<p><2>.优点：结构化，类似于 JAVA 的结构，清晰明了，底层用到了 JQUERY 的一些函数，使整合使用有了选择，最重要的一点是界面太让让人震撼了。</2></p>
<p><3>.缺点：太过复杂，整个界面的构造过于复杂。</3></p>
<p>(3).DOJO </p>
<p><1>.介绍<br>DOJO 是目前最为强大的JS框架，它在自己的 WIKI 上给自己下了一个定义，DOJO 是一个用 JAVASCRIPT 编写的开源的DHTML工具箱。DOJO 很想做一个“大一统”的工具箱，不仅仅是浏览器层面的，野心还是很大的。DOJO 包括 AJAX、BROWSER、EVENT、WIDGET 等跨浏览器 API，包括了 JS 本身的语言扩展，以及各个方面的工具类库，和比较完善的 UI 组件库，也被广泛应用在很多项目中，他的 UI 组件的特点是通过给 HTML 标签增加 TAG 的方式进行扩展，而不是通过写 JS 来生成，DOJO 的 API 模仿 JAVA 类库的组织方式。用 DOJO 写 WEB OS 可谓非常方便。DOJO 现在已经 4.0 了，DOJO 强大的地方在于界面和特效的封装，可以让开发者快速构建一些兼容标准的界面。</1></p>
<p><1>.优点：库相当完善，发展时间也比较长，功能强大，据说利用 DOJO 的 IO.BIND() 可以实现 COMET 看见其功能强大非一般，得到 IBM 和 SUN 的支持。</1></p>
<p><2>.缺点：文件体积比较大，200多KB，初次下载相当慢，此外，DOJO 的类库使用显得不是那么易用，JS语法增强方面不如 PROTOTYPE</2></p>
<p>(4).PROTOTYPE </p>
<p><1>.介绍<br>它是一个非常优雅的 JS 库，定义了 JS 的面向对象扩展，DOM 操作API，事件等等，以 PROTOTYPE 为核心，形成了一个外围的各种各样的 JS 扩展库，是相当有前途的 JS 底层框架，值得推荐，感觉也是现实中应用最广的库类（ROR 集成的 AJAX JS 库），之上还有 SCRIPTACULOUS 实现一些JS组件功能和效果。</1></p>
<p><2>.优点：基本底层，易学易用，甚至是其他一些JS特效开发包的底层，体积算是最小的了。</2></p>
<p><3>.缺点：如果说缺点，可能就是功能是他的弱项</3></p>
<p>(5).DSCRIPTACULOUS </p>
<p><1>.介绍<br>SCRIPTACULOUS 是基于PROTOTYPE.JS 框架的 JS 效果。包含了 6 个 JS 文件，不同的文件对应不同的 JS 效果，所以说，如果底层用 PROTOTYPE 的话，做JS效果用 SCRIPTACULOUS 那是再合适不过的了，连大名鼎鼎的 DIGG 都在用他，可见不一般</1></p>
<p><2>.优点：基于PROTOTYPE 是最大的优点，由于使用 PROTOTYPE 的广泛性，无疑对用户书锦上添花。</2></p>
<p><3>.缺点：刚刚兴起，需要时间的磨练</3></p>
<p>(6).MOCHIKIT </p>
<p><1>.介绍<br>MOCHIKIT 自称为一个轻量级的 JS 框架。MOCHIKIT 主要受到 PYTHON 和 PYTHON 标准库提供的很多便利之处的启发，另外还缓解了浏览器版本之间的不一致性。其中的 MOCHIKIT.DOM 尤其方便，能够以比原始 JAVASCRIPT 更友好的方式处理 DOM 对象。MOCHIKIT.DOM 大部分都是针对 XHTML 文档定制的，如果与 MOCHIKIT 和 AJAX 结合在一起，使用 XHTML 包装的微格式尤其方便。MOCHIKIT 可以直接对字符串或者数字格式化输出，比较实用和方便。它还有自己的 JS 代码解释器</1></p>
<p><2>.优点：MOCHIKIT.DOM 这部分很实用，简介也是很突出的</2></p>
<p><3>.缺点：轻量级的缺点</3></p>
<p>(7).MOOTOOLS </p>
<p><1>.介绍<br>MOOTOOLS 是一个简洁，模块化，面向对象的 JAVASCRIPT 框架。它能够帮助你更快，更简单地编写可扩展和兼容性强的 JAVASCRIPT 代码。MOOTOOLS 跟 PROTOTYPEJS 相类似，语法几乎一样。但它提供的功能要比 PROTOTYPEJS 多，而且更强大。比如增加了动画特效、拖放操作等等。 </1></p>
<p><2>.优点：可以定制自己所需要的功能，可以说是 PROTOTYPEJS 的增强版。</2></p>
<p><3>.缺点：不大不小，具体应用具体分析。</3></p>
<p>(8).MOO.FX </p>
<p><1>.介绍<br>MOO.FX是 一个超级轻量级的 JAVASCRIPT 特效库（7K），能够与 PROTOTYPE.JS 或MOOTOOLS 框架一起使用。它非常快、易于使用、跨浏览器、符合标准，提供控制和修改任何 HTML 元素的 CSS 属性，包括颜色。它内置检查器能够防止用户通过多次或疯狂点击来破坏效果。MOO.FX整体采用模块化设计，所以可以在它的基础上开发你需要的任何特效。 </1></p>
<p><2>.优点：小块头有大能耐</2></p>
<p><3>.缺点：这么小了，已经不错了<br>PERL<br>特点：<br>集成了正则表达式的功能<br>主要用途：<br>WEB编程、数据库处理、XML处理以及系统管理<br>优点：<br>PERL追求的是简单, 解决一个一般的问题用它几行代码就完成了. 一个稍复杂一点的问题代码也不会超过一屏! 在软件测试中，PERL通常是非常重要的角色。一般一个测试通用函数库就要分十几个文件，甚至更多，包含多达上千个定制功能。而这些函数将在主函数运行时，不定数量的被调用。几乎可以说，一切自动过程都是由PERL自己完成的，可见其功能的强大和在当今计算机技术高速发展的时期仍然发挥着重要的作用。</3></p>
<p>PERL 最初是当做一种 UNIX 的脚本语言设计的，但是它早就移植到大多数其它操作系统里了。因为 PERL 几乎可以在任何地方运行，所以 PERL 可以说是当今最具有移植性的编程环境；要想写可移植的 C/C++ 程序，你得在程序里加上一大堆 #IFDEF 标签来区分不同的系统；要想写可移植的 JAVA 程序，你必须理解每种新的 JAVA 实现的特质；要想写可移植的SHELL，你可能要记住每条命令在每种操作系统上的语法，走运的时候你可能可以找到一些公共的东西；要想写可移植的 VISUAL BASIC 程序，需要对“移植”有个更灵活的定义。</p>
<p>让我们很高兴的是 PERL 避免了所有这些问题，同时还保留了这些语言中的许多优点，同时还有一些自己的特色。PERL 的特色来自许多方面：它的特性集的工具，PERL 社区的创造性，以及开源运动的大环境。不过，许多这些特性都是混合的东西；PERL 的身世复杂，它总是把事物看成是优点的不同方面，而不是弱点。PERL 是“背黑锅我来”的语言。如果你觉得自己陷入一团乱麻之中，非常渴望自由，那么请使用 PERL。</p>
<p>PERL 是跨文化的。PERL 的爆炸性增长很大程度上是因为那些前 UNIX 系统程序员的渴望，他们希望从他们的“老家”带着尽可能多的东西。对于他们而言，PERL 是可移植的 UNIX 文化蒸馏器，是”此路不通”的沙漠中的绿洲。从另外一个角度来看，PERL 还可以从另外一个方向运转：在 WINDOWS 上工作的 WEB 设计者通常会非常开心地发现他们的 PERL 程序可以不加修改地在 UNIX 服务器上跑。</p>
<p>尽管 PERL 在系统程序员和 WEB 设计师中间非常流行，但这只是因为是他们最早发现 PERL 的，PERL 可以用于更广泛的用途。从 PERL 最早的文本处理语言开始，它已经发展成为一种非常复杂的，通用的编程语言，以及完整的开发环境，包括调试器，调节器，交叉引用，编译器，库，语法提示编辑器，以及所有其它“真正”的编程语言所具有的所有挂勾，只要你需要。当然这些东西都是让我们可能处理难的问题的东西，而且很多其它语言也可以做到这一点。PERL 之所以成为 PERL 是因为它从来不会因为保持简单事情简单化而丢失其他方面的特性。</p>
<p>因为 PERL 既强大又好用，所以它被广泛地用于日常生活的方方面面，从宇航工程到分子生物学，从数学到语言学，从图形处理到文档处理，从数据库操作到网络管理。很多人用 PERL 进行快速处理那些很难分析或转换的大批量数据，不管你是处理 DNA 序列，网页，还是猪肚皮的未来都无所谓。实际上，在 PERL 社区有一个笑话就是，下次股市大崩盘就很有可能是哪个家伙写的脚本里头有BUG造成的。（不过，乐观点来看就是，任何还在失业的股票分析师仍然有可以利用的技巧。）</p>
<p>PERL 的成功有许多原因。PERL 早在开源软件的名字出现之前就已经是一个成功的开源项目了。PERL 是自由的，并将永远自由下去。你可以在任何合适的场合使用 PERL，只需要遵守一个非常自由的版权就可以了。如果你在从事商业活动并且还想使用 PERL，那么用就是了。你可以把 PERL 嵌入到你写的商业软件中而不需要支付任何费用也没有任何限制。如果你碰上一个 PERL 社区解决不了的问题，那你也还有最后的一招：源程序本身。 PERL 社区不会在“升级”的伪装下租给你它们的商业秘密。而且 PERL 社区也不会“停业 ”，更不会让你孤立无援。</p>
<p>PERL 是自由软件这一点无疑对它是有帮助的。但这一条并不足以解释 PERL 现象，因为许多自由软件包没有能繁荣起来。PERL 不仅自由；而且好玩。人们觉得自己在 PERL 里可以有创造力，因为它们有表达的自由：他们可以选择是为计算机速度优化还是为程序员的速度优化，是冗长还是简洁，是选择可读性还是可维护性，或者选择复用性，移植性，接受性和传授性等等。假如你进入一次模糊的 PERL 比赛，甚至你还可以为模糊性做优化。</p>
<p>PERL 可以给予你所有这些自由，因为它是一门有着分裂人格的语言。PERL 同时是很简单并且很富有的语言。PERL 从其它地方拿来好主意，然后把它们安装到易用的框架里面。对于只是喜欢她的人来说，PERL 是实用抽取和报表语言（PRACTICAL EXTRACTOIN AND REPORT LANGUAGE）。对那些热爱她的人而言，她是变态电子垃圾制造者（PATHOLOGICALLY ELECTRIC RUBBISH LISTER）。在少数人眼里，PERL 是毫无意义的重复练习。不过世界需要一点点冗余。精简主义者总是想把事物分隔开。而我们则总是企图把它们合并到一起。</p>
<p>PERL 之所以是简单的语言是有很多原因的。比如你用不着知道什么特殊的指令就可以编译 PERL 程序–只要把它当做批处理或者 SHELL 脚本执行就可以了。PERL 的类型和结构很容易使用和理解。PERL 对你的数据没有任何限制–你的字串和数组可以要多长就多长（只要你有足够的内存），而且它们都会自动增长。PERL 不会强迫你学习新的语法和语意，PERL 改从许多其它你已经熟悉的语言里（比如 C, AWK, BASIC 和 PYTHON, 英文，希腊语等）借来语法。实际上，任何程序员都可以从书写良好的 PERL 代码段中读懂它的含义。</p>
<p>最重要的是，你不用先学习所有 PERL 的东西就可以开始写有用的程序。你可以写很小的 PERL 程序。你也可以象小孩那样写 PERL 程序，我们保证不会笑话你。或者更准确地说是，我们绝不会笑话小孩做事情的创造性。PERL 里的许多观点都是从自然语言中借来的，其中一条最好的观点就是只要你能把自己的意思表述清楚，那么你就可以使用这些语言的一个子集。PERL 文化可以接受任何熟练程度的成员。我们不会在你背后放个语言警察。如果你的老板不炒你，而且你的 PERL 脚本也能完成工作，那么它就是“正确”的。</p>
<p>尽管 PERL 很简单，但它仍然是一种特性很丰富的语言，如果你想用那些特性的话，那你就要学习一些东西。这也是把难题变简单的学费。虽然你要想把所有 PERL 能做的事情吸收还需要一些时间，但到你需要这些功能的时候你就会非常开心地发现 PERL 已经可以做这些事情了。</p>
<p>由于 PERL 的继承性，就算它只是用做数据归纳语言的时候也有丰富的特性，PERL 一开始就设计成可以浏览文件，扫描大量文本并且生成动态数据以及打印出这些数据的良好格式化的报表。不过，随后 PERL 就开始风行，于是它就成了可以操作文件系统，进程管理，数据库管理，进行 C/S 编程和安全编程，WEB 信息管理，甚至可以进行面向对象和面向功能的编程的语言。而且这些功能并非只是在 PERL 这边，每种新功能都和其它东西交流得很好，别忘了 PERL 从一开始就是设计成胶水语言的。</p>
<p>而且 PERL 并不仅仅只能黏合它自己的特性。PERL 是设计成可以用模块扩展的语言。你可以用 PERL 快速设计，编写，调试和部署 PERL 应用，并且你还可以在需要的时候很方便地扩展这些应用。你可以在其它语言里嵌入 PERL，而且你也可以在 PERL 里嵌入其它语言。通过模块输入机制，你可以把这些外部的扩展当做内置于 PERL 的特性。那些面向对象的外部库在 PERL 内部仍然保持面向对象的特征。</p>
<p>PERL 还在许多其它方面协助你。和严格的每次执行一条命令的命令文件和 SHELL 脚本不同的是，PERL 先把你的程序快速编译成一种内部格式。和其它任何编译器一样，这个时候还进行各种优化，同时把碰到的任何问题反馈给你。一旦 PERL 的编译器前端对你的程序表示满意了，它就把这些中间代码交给解释器执行（或者是给其它的能生成 C 或者字节码的模块后端）。听起来挺复杂，不过 PERL 的编译器和解释器干这些活效率相当高，我们的编译-运行-修改的过程几乎都是以秒计。再加上 PERL 的许多其他开发特性，这种快速的角色转换很适合做快速原型设计。然后随着你的程序的成熟，你可以逐步拧紧身上的螺母，减少散漫增强纪律。如果你做得好，PERL 也能帮你这个忙。</p>
<p>PERL 还可以帮你写更安全的程序。除了其它语言提供的典型的安全接口之外，PERL 还通过一种跟踪数据的机制给你提供预防意外安全错误的保护，这样就可以在灾害发生之前预防其发生。最后，PERL 还可以让你设置一个特殊的防护隔段运行那些来源不明的 PERL 代码，以此来杜绝危险操作。</p>
<p>不过，偏执一点儿说，PERL 帮你的大部分内容和 PERL 本身没有什么关系，而是和使用 PERL 的人有关。坦率地说，PERL 社区的人们可以说是地球上最热心的人了。如果 PERL 运动里面有那么一点点宗教色彩的话，那么这就是它的核心了。LARRY 希望 PERL 社区像一小片天堂那样运转，目前看来他的愿望基本上是实现了。我们也请你为此做出自己的努力。</p>
<p>PERL之所以强大, 是因为有CPAN, CPAN上面有无数的开源模块, 从科学计算到桌面应用到网络等等各个方面都有大量的模块! 并且世界上也还有无数的人在向上面添加模块! 如果你想要用PERL实现某功能, 不用自己做, 在CPAN上面搜一搜, 多半都会得到已有的结果! CPAN（”THE COMPREHENSIVE PERL ARCHIVE NETWORK”全面的 PERL 存档网络）是查找任何 PERL 有关的东西的中心仓库。它包含从整个 PERL 社区收集来的智慧：成百上千的 PERL 模块和脚本，相当于好几本书的文档，以及整个 PERL 发布。如果有东西是用 PERL 写的，而且这个东西很有用而且是自由的，那么它很有可能就在 CPAN 上。<br>缺点：<br>也正是因为PERL的灵活性和“过度”的冗余语法，也因此获得了WRITE-ONLY的“美誉”，因为许多PERL程序的代码令人难以阅读，实现相同功能的程序代码长度可以相差十倍百倍。但PERL同样可以将代码书写得像PYTHON或RUBY等语言一样优雅。</p>
<p>很多时候，PERL.EXE进程会占用很多的内存空间，虽然只是一时，但是感觉不好。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/IT/">IT</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IT/">IT</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-如何理解面向对象和面向过程？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/30/如何理解面向对象和面向过程？/" class="article-date">
      <time datetime="2018-05-30T06:04:54.000Z" itemprop="datePublished">2018-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/30/如何理解面向对象和面向过程？/">如何理解面向对象和面向过程？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/images/pic14.jpg" alt="&quot;IT”"><br>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。<br>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。<br>例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用分别的函数来实现，问题就解决了。<br>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为 1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的i变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。<br>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。<br>功能上的统一保证了面向对象设计的可扩展性。比如我要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。<br>再比如我要把这个五子棋游戏改为围棋游戏，如果你是面向过程设计，那么五子棋的规则就分布在了你的程序的每一个角落，要改动还不如重写。但是如果你当初就是面向对象的设计，那么你只用改动规则对象就可以了，五子棋和围棋的区别不就是规则吗？（当然棋盘大小好像也不一样，但是你会觉得这是一个难题吗？直接在棋盘对象中进行一番小改动就可以了。）而下棋的大致步骤从面向对象的角度来看没有任何变化。<br>当然，要达到改动只是局部的需要设计的人有足够的经验，使用对象不能保证你的程序就是面向对象，初学者或者很蹩脚的程序员很可能以面向对象之虚而行面向过程之实，这样设计出来的所谓面向对象的程序很难有良好的可移植性和可扩展性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/IT/">IT</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IT/">IT</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-中国互联网历史中的25个故事——互联网人的那些传奇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/11/中国互联网历史中的25个故事——互联网人的那些传奇/" class="article-date">
      <time datetime="2018-05-11T06:04:54.000Z" itemprop="datePublished">2018-05-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/11/中国互联网历史中的25个故事——互联网人的那些传奇/">中国互联网历史中的25个故事——互联网人的那些传奇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/images/121.png" alt="&quot;BAT”"><br>   中国的互联网发展到现在这个程度，应该算是非常成功的。想想10年前我们的互联网是怎样的，再想想20年前我们的互联网又是怎样的。十几年前QQ还叫OICQ,网易还没做游戏，百度还没出现，刘强东还在电脑城摆摊卖配件，曾经最大的下载工具还是网络蚂蚁，南非电讯投资腾讯的时候，所有媒体人都觉得南非人SB…而如今这个场景，应该谁都想不到的。下面25个点，回顾中国曾经的互联网。<br>　<br>      1、最早在美国上市的中国互联网公司是中华网，域名牛逼，中国概念，一度股价爆高到100多美元，后来一路跌到地板，然后退市，现在，谁还记得呢。<br>　<br>      2、曾经联想搞了一个fm365.com，联想的互联网战略，非常非常早的事情，随着联想电脑预装铺开，一度号称是国内门户前几名，然后呢?后来一度域名都丢了，然后也没有然后了。<br>　<br>      3、我们知道现在最大的文学站是起点文学，最大的下载一个是华军软件，一个是百度收购天空下载。但曾经最大的文学站黄金书屋，最大的下载站是海阔天空，然而这些网站都被一个叫多来米的公司用很低的价格收购了，那时候个人站不值钱啊，然后呢，多来米收了一堆当时最好的个人站，结果全做死了。<br>　<br>      4、最早的电子商务网站，8848.com，曾经是中国电子商务网站头牌，在上市关键时刻的临门一脚，没有成功，然后，每况愈下。</p>
<p><img src="/images/131.jpg" alt="&quot;BAT”">  </p>
<p>  　6、第一只A股上的互联网概念股叫做海虹控股，当时他们控股了中国最大的，完全独孤求败的棋牌游戏平台，联众游戏。 然后慢慢的联众就废掉了，一步步落后于时代。 今天我们不要说腾讯了，说波克城市这样的棋牌平台，收入我估计都比联众高不少。</p>
<p>　　7、曾经最大的下载工具叫做网络蚂蚁。</p>
<p>　　8、互联网泡沫破裂的时候，网易是三大门户里最脆弱的，一度股价掉到1块钱以内，丁磊炒掉了他聘用的CEO，财务出现丑闻，媒体天天给网易做退市的倒计时，大家都在幸灾乐祸，然而今天我们看，三大门户里网易转身最快，新业务拓展最成功，现在游戏市场，腾讯拿他也没办法。</p>
<p>　　9、南非电讯投资腾讯的时候，所有媒体人都觉得南非人SB，被马化腾骗了，说马化腾的估值方式完全是蒙人的，oicq用户(当时不叫QQ)都是低龄低层次用户，没有消费能力。 现在作为腾讯股东的价值和回报是南非电讯集团当前市值最大的支撑，超过其本身自营业务。。</p>
<p>　　10、曾经大家都认为中国互联网大局已定，新浪搜狐的霸主地位无可动摇，今天回头看，呵呵。</p>
<p>　　11、百度和新浪曾经撕逼过，百度那时候还是技术服务商，新浪的搜索是百度提供技术支持的，然后，新浪拖欠了百度的技术服务费，李彦宏一怒之下停了新浪的搜索接口，媒体都认为百度疯了，互联网霸主新浪分分钟捏死百度，这也是李彦宏摔电话决心自己做用户的主要原因之一。</p>
<p>　　12、曾经有一种期盼，说中国互联网啥时候能出市值超过十亿美元的巨头啊，呵呵。</p>
<p>　　13、百度上市的时候市值破百亿美元，市盈率过千，当时基本上国内所有分析师都说百度被严重高估了。</p>
<p>　　14、中国做游戏是不可能赚钱的，中国人没有人会为游戏付费，这是在2002年之前行业的共识，当时说的游戏主要是pc游戏，台湾和日本的游戏在大陆都很流行，直到盛大突然崛起，一切都变了。</p>
<p>　　15、群聊功能最早是朗玛uc推出的，市场反馈极好，当时用户发展极快，新浪见状立刻收购。那时候腾讯想做用户变现，取消了电脑注册QQ的功能，只允许手机短信验证码注册，一个注册收一块钱，结果看到朗玛uc有取代之势，立即恢复免费注册，同时推出QQ群，然后新浪这次投资基本就失败了。</p>
<p>　　16、百度推出过一个百度hi的聊天工具，还有一个百度有啊的电商平台，不过今天大部分年轻人都没听说过。 我的头像来源于是百度hi当时的气泡熊表情包，我觉得百度hi最有价值的成果就是气泡熊表情做的确实不错。</p>
<p>　　17、网景浏览器曾经被认为是一种革命，市场占有率一度在80%以上，当时网景的野心很大，想用浏览器做网络终端操作系统，市场也极为认可，股价和市值扶摇直上，很多投资者都认为网景可能是互联网时代的微软，然后微软内置了浏览器，网景告微软垄断，官司一直打，微软浏览器市场份额一直上升，然后，官司没打完，网景完了。 但有意思的是，现在，国内有360浏览器，国外的火狐，google的chrome浏览器，市场占有率都不低;为什么当时网景模式没成功，而现在第三方浏览器又都冒出来了，所以，归咎于微软垄断和捆绑，不如多思考自己的问题。</p>
<p>　　我给一个答案，网景的思路是互联网上的软件公司，而如今第三方浏览器完全是走互联网模式，做软件公司，被微软掐死是分分钟的事情。</p>
<p><img src="/images/122.jpeg" alt="&quot;BAT”"> </p>
<p>　　18、2000年左右微软推搜索引擎，当时还不是bing，是MSN搜索，国内分析师近乎一致认为google要完，大家都觉得微软的技术能力很强，有钱，有资源，又能铺终端，但当时俞军老师坚持认为微软根本不懂搜索，不会冲击google，我特意翻过旧帖，从此转为俞军脑残粉。</p>
<p>　　19、吴京川老师十几年前给我讲搜索套利模式的时候，我完全没听懂，几年后我看一些新闻案例突然明白了，然后感慨市场时机过去了，直到最近我才知道，其实市场时机一直都在，只是进入门槛越来越高而已，意识到自己简直蠢的不可救药。</p>
<p>　　20、地方电信的门户网站和其附属的一些资源，社区曾经一度占据互联网流量的半壁江山，比较有名的包括上海热线，贵州信息港，碧海银沙等等。</p>
<p>　　21、网易最早就是个个人站，丁磊是中国最大的个人站长，当时丁磊要搞免费邮局，去广州电信谈合作，说不要电信出一分钱共同搭建一个邮局平台，只要电信出带宽资源。(当时流量带宽老贵老贵的，但对于电信来说成本极低)，合作，然后未来广告收入大家分啥的巴拉巴拉。 当时的局长张静君一听，没听懂，但是禁不住她琢磨，不要出钱还能分钱，有这么好的事情?这里肯定藏着很大的利益，这好事不能让丁磊占了，这样，我直接买你们系统。 于是就有了163.net免费邮局，国内第一个免费邮局，用户量果然激增，因为没有其他家啊，然而做了很久，也没赚到钱，后来这个邮局被卖掉了还涉及国有资产流失啥的，张静君后来出去创业，一度被认为是互联网大佬，继续呵呵吧。 当然，丁磊也够坏的，卖了163.net给电信，自己掖着163.com。</p>
<p>　　22、腾讯最早域名是tencent.com，百度 cdn 长期有个跳转域名叫做shifen.com 大家都是1毛， 这事哪说理去。 美国的巨头叫做微软，中国的巨头叫做1毛。</p>
<p>　　23、李彦宏，周鸿祎，马化腾，雷军，丁磊，史玉柱，最早都是程序员，而且都还是水平相当不错的程序员，当然更不用说张志东这样的了。其实这个名单可以拉很长，很多名气没那么大的上市公司老板其实也做过程序员，比如携程老板梁建章等等。</p>
<p>　　24、个人网站</p>
<p>　　南杨北高曾经是个人网站最早的传奇，高春辉的个人主页曾经是国内网站综合排名前十，汽车销售员出身的第一代站长杨震霆目前已经移民加拿大，当地华人没有几个知道他曾经辉煌的历史;而高春辉依然在连续创业，中国互联网草根创业者的活化石。 可能很少人知道，卓越网的第一任老板是高春辉，而那时候卓越网，是一个下载站。</p>
<p>　　躲在梅州几乎从不出远门，从不接受采访以及从不参加各种峰会(实际上，只参加过一次)的中专生李兴平 创造了草根网站最大的奇迹，他依靠本地的几个人的小团队，先后创建过三个曾经位居国内访问量前20的网站，hao123, qq163 和 4399。而其他诸如3533，ip138，oicq88等一堆网站也都各个流量不菲，最疯狂的时候，一个音乐个人站长，和李兴平私交不错，就能轻松从他那里获得每天十几万到几十万的访问来路。</p>
<p>　　当然，今天，个人站长的时代过去了。</p>
<p>　　25、关于拥抱变化</p>
<p>　　百度最早是给门户做搜索技术服务商，没打算自己做流量入口;</p>
<p>　　腾讯最早想给电信做网络寻呼系统，没打算自己做用户，当时想发展点用户做样本测试系统;结果电信不鸟他，幸亏电信不鸟他。</p>
<p>　　阿里最开始做企业黄页;</p>
<p>　　盛大最开始做社区，失败了后用最后剩下的钱代理了传奇，当时大家都觉得中国游戏没市场，所以代理金极低;</p>
<p>　　京东最开始中关村摆摊的不解释;</p>
<p>　　唯品会开始搞奢侈品赔的一塌糊涂，转入二线品牌开始翻身;</p>
<p>　　聚美优品陈欧第一次创业是做游戏广告平台，然后转型卖了化妆品;</p>
<p>　　奇虎最开始做社区搜索，恶心阿里搞了360去弄死3721，没想到无心栽柳;</p>
<p>　　新浪最开始是四通利方论坛，收了海外一个华人门户后转型做门户，然后靠微博翻身;</p>
<p>　　网易从虚拟社区到邮局到门户到移动SP到游戏;</p>
<p>　　搜狐从门户到游戏;</p>
<p>现在你告诉我你看准了一个大方向保证未来很有前途??</p>
<p>你可以当八卦看，也可以多想想，沧海桑田的背后，为什么。然后想想，未来会怎样?我们是不是还会看走眼，选错路?</p>
<p>(转载自鸡啄米：<a href="http://www.jizhuomi.com/internet/688.html）" target="_blank" rel="noopener">http://www.jizhuomi.com/internet/688.html）</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Internet/">Internet</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IT互联网/">IT互联网</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-流行的 15 个数据科学 Python 库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/06/流行的 15 个数据科学 Python 库/" class="article-date">
      <time datetime="2018-05-06T06:04:54.000Z" itemprop="datePublished">2018-05-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/06/流行的 15 个数据科学 Python 库/">流行的15个数据科学Python库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>编程互联</p>
<p>转自码农网，作者：朱朝阳</p>
<p><a href="http://www.codeceo.com/article/15-data-science-python-libraries.html" target="_blank" rel="noopener">http://www.codeceo.com/article/15-data-science-python-libraries.html</a></p>
<p>Python 近几年在数据科学行业获得了人们的极大青睐，各种资源也层出不穷。数据科学解决方案公司 ActiveWizards 近日根据他们自己的应用开发经验，总结了数据科学家和工程师将在 2017 年最常使用的 Python 库。</p>
<p>1）NumPy</p>
<p>地址：<a href="http://www.numpy.org" target="_blank" rel="noopener">http://www.numpy.org</a></p>
<p>当使用 Python 开始处理科学任务时，不可避免地需要求助 Python 的 SciPy Stack，它是专门为 Python 中的科学计算而设计的软件的集合（不要与 SciPy 混淆，它只是这个 stack 的一部分，以及围绕这个 stack 的社区）。这个 stack 相当庞大，其中有十几个库，所以我们想聚焦在核心包上（特别是最重要的）。</p>
<p>NumPy（代表 Numerical Python）是构建科学计算 stack 的最基础的包。它为 Python 中的 n 维数组和矩阵的操作提供了大量有用的功能。该库还提供了 NumPy 数组类型的数学运算向量化，可以提升性能，从而加快执行速度。</p>
<p>2）SciPy</p>
<p>地址：<a href="https://www.scipy.org" target="_blank" rel="noopener">https://www.scipy.org</a></p>
<p>SciPy 是一个工程和科学软件库。除此以外，你还要了解 SciPy Stack 和 SciPy 库之间的区别。SciPy 包含线性代数、优化、集成和统计的模块。SciPy 库的主要功能建立在 NumPy 的基础之上，因此它的数组大量使用了 NumPy。它通过其特定的子模块提供高效的数值例程操作，比如数值积分、优化和许多其他例程。SciPy 的所有子模块中的函数都有详细的文档，这也是一个优势。</p>
<p>3）Pandas</p>
<p>地址：<a href="http://pandas.pydata.org" target="_blank" rel="noopener">http://pandas.pydata.org</a></p>
<p>Pandas 是一个 Python 包，旨在通过「标记（labeled）」和「关系（relational）」数据进行工作，简单直观。Pandas 是 data wrangling 的完美工具。它设计用于快速简单的数据操作、聚合和可视化。库中有两个主要的数据结构：</p>
<p>Series：一维</p>
<p>Data Frames：二维</p>
<p>例如，当你要从这两种类型的结构中接收到一个新的「Dataframe」类型的数据时，你将通过传递一个「Series」来将一行添加到「Dataframe」中来接收这样的 Dataframe：</p>
<p>这里只是一小撮你可以用 Pandas 做的事情：</p>
<p>轻松删除并添加「Dataframe」中的列</p>
<p>将数据结构转换为「Dataframe」对象</p>
<p>处理丢失数据，表示为 NaN（Not a Number）</p>
<p>功能强大的分组可视化</p>
<p>4）Matplotlib</p>
<p>地址：<a href="https://matplotlib.org" target="_blank" rel="noopener">https://matplotlib.org</a></p>
<p>Matplotlib 是另一个 SciPy Stack 核心软件包和另一个 Python 库，专为轻松生成简单而强大的可视化而量身定制。它是一个顶尖的软件，使得 Python（在 NumPy、SciPy 和 Pandas 的帮助下）成为 MatLab 或 Mathematica 等科学工具的显著竞争对手。然而，这个库比较底层，这意味着你需要编写更多的代码才能达到高级的可视化效果，通常会比使用更高级工具付出更多努力，但总的来说值得一试。花一点力气，你就可以做到任何可视化：</p>
<p>线图</p>
<p>散点图</p>
<p>条形图和直方图</p>
<p>饼状图</p>
<p>茎图</p>
<p>轮廓图</p>
<p>场图</p>
<p>频谱图</p>
<p>还有使用 Matplotlib 创建标签、网格、图例和许多其他格式化实体的功能。基本上，一切都是可定制的。</p>
<p>该库支持不同的平台，并可使用不同的 GUI 工具套件来描述所得到的可视化。许多不同的 IDE（如 IPython）都支持 Matplotlib 的功能。</p>
<p>还有一些额外的库可以使可视化变得更加容易。</p>
<p><img src="/images/135.jpg" alt="&quot;language”"></p>
<p>5）Seaborn</p>
<p>地址：<a href="https://seaborn.pydata.org" target="_blank" rel="noopener">https://seaborn.pydata.org</a></p>
<p>Seaborn 主要关注统计模型的可视化；这种可视化包括热度图（heat map），可以总结数据但也描绘总体分布。Seaborn 基于 Matplotlib，并高度依赖于它。</p>
<p><img src="/images/136.jpg" alt="&quot;language”"></p>
<p>6）Bokeh</p>
<p>地址：<a href="http://bokeh.pydata.org" target="_blank" rel="noopener">http://bokeh.pydata.org</a></p>
<p>Bokeh 也是一个很好的可视化库，其目的是交互式可视化。与之前的库相反，这个库独立于 Matplotlib。正如我们已经提到的那样，Bokeh 的重点是交互性，它通过现代浏览器以数据驱动文档（D3.js）的风格呈现。</p>
<p><img src="/images/137.jpg" alt="&quot;language”"></p>
<p>7）Plotly</p>
<p>地址：<a href="https://plot.ly" target="_blank" rel="noopener">https://plot.ly</a></p>
<p>最后谈谈 Plotly。它是一个基于 Web 的工具箱，用于构建可视化，将 API 呈现给某些编程语言（其中包括 Python）。在 plot.ly 网站上有一些强大的、开箱即用的图形。为了使用 Plotly，你需要设置你的 API 密钥。图形处理会放在服务器端，并在互联网上发布，但也有一种方法可以避免这么做。</p>
<p><img src="/images/138.jpg" alt="&quot;language”"></p>
<p>机器学习8）SciKit-Learn</p>
<p>地址：<a href="http://scikit-learn.org" target="_blank" rel="noopener">http://scikit-learn.org</a></p>
<p>Scikits 是 SciPy Stack 的附加软件包，专为特定功能（如图像处理和辅助机器学习）而设计。在后者方面，其中最突出的一个是 scikit-learn。该软件包构建于 SciPy 之上，并大量使用其数学操作。</p>
<p>scikit-learn 有一个简洁和一致的接口，可利用常见的机器学习算法，让我们可以简单地在生产中应用机器学习。该库结合了质量很好的代码和良好的文档，易于使用且有着非常高的性能，是使用 Python 进行机器学习的实际上的行业标准。</p>
<p>深度学习：Keras / TensorFlow / Theano</p>
<p>在深度学习方面，Python 中最突出和最方便的库之一是 Keras，它可以在 TensorFlow 或者 Theano 之上运行。让我们来看一下它们的一些细节。</p>
<p>9）Theano</p>
<p>地址：<a href="https://github.com/Theano">https://github.com/Theano</a></p>
<p>首先，让我们谈谈 Theano。Theano 是一个 Python 包，它定义了与 NumPy 类似的多维数组，以及数学运算和表达式。该库是经过编译的，使其在所有架构上能够高效运行。这个库最初由蒙特利尔大学机器学习组开发，主要是为了满足机器学习的需求。</p>
<p>要注意的是，Theano 与 NumPy 在底层的操作上紧密集成。该库还优化了 GPU 和 CPU 的使用，使数据密集型计算的性能更快。</p>
<p>效率和稳定性调整允许更精确的结果，即使是非常小的值也可以，例如，即使 x 很小，log(1+x) 也能得到很好的结果。</p>
<p>10）TensorFlow</p>
<p>地址：<a href="https://www.tensorflow.org" target="_blank" rel="noopener">https://www.tensorflow.org</a></p>
<p>TensorFlow 来自 Google 的开发人员，它是用于数据流图计算的开源库，专门为机器学习设计。它是为满足 Google 对训练神经网络的高要求而设计的，是基于神经网络的机器学习系统 DistBelief 的继任者。然而，TensorFlow 并不是谷歌的科学专用的——它也足以支持许多真实世界的应用。</p>
<p>TensorFlow 的关键特征是其多层节点系统，可以在大型数据集上快速训练人工神经网络。这为 Google 的语音识别和图像识别提供了支持。</p>
<p>11）Keras</p>
<p>地址：<a href="https://keras.io" target="_blank" rel="noopener">https://keras.io</a></p>
<p>最后，我们来看看 Keras。它是一个使用高层接口构建神经网络的开源库，它是用 Python 编写的。它简单易懂，具有高级可扩展性。它使用 Theano 或 TensorFlow 作为后端，但 Microsoft 现在已将 CNTK（Microsoft 的认知工具包）集成为新的后端。</p>
<p>其简约的设计旨在通过建立紧凑型系统进行快速和容易的实验。</p>
<p>Keras 极其容易上手，而且可以进行快速的原型设计。它完全使用 Python 编写的，所以本质上很高层。它是高度模块化和可扩展的。尽管它简单易用且面向高层，但 Keras 也非常深度和强大，足以用于严肃的建模。</p>
<p>Keras 的一般思想是基于神经网络的层，然后围绕层构建一切。数据以张量的形式进行准备，第一层负责输入张量，最后一层用于输出。模型构建于两者之间。</p>
<p>12）NLTK</p>
<p>地址：<a href="http://www.nltk.org" target="_blank" rel="noopener">http://www.nltk.org</a></p>
<p>这套库的名称是 Natural Language Toolkit（自然语言工具包），顾名思义，它可用于符号和统计自然语言处理的常见任务。NLTK 旨在促进 NLP 及相关领域（语言学、认知科学和人工智能等）的教学和研究，目前正被重点关注。</p>
<p>NLTK 允许许多操作，例如文本标记、分类和 tokenizing、命名实体识别、建立语语料库树（揭示句子间和句子内的依存性）、词干提取、语义推理。所有的构建块都可以为不同的任务构建复杂的研究系统，例如情绪分析、自动摘要。</p>
<p>13）Gensim</p>
<p>地址：<a href="http://radimrehurek.com/gensim" target="_blank" rel="noopener">http://radimrehurek.com/gensim</a></p>
<p>这是一个用于 Python 的开源库，实现了用于向量空间建模和主题建模的工具。这个库为大文本进行了有效的设计，而不仅仅可以处理内存中内容。其通过广泛使用 NumPy 数据结构和 SciPy 操作而实现了效率。它既高效又易于使用。</p>
<p>Gensim 的目标是可以应用原始的和非结构化的数字文本。Gensim 实现了诸如分层 Dirichlet 进程（HDP）、潜在语义分析（LSA）和潜在 Dirichlet 分配（LDA）等算法，还有 tf-idf、随机投影、word2vec 和 document2vec，以便于检查一组文档（通常称为语料库）中文本的重复模式。所有这些算法是无监督的——不需要任何参数，唯一的输入是语料库。</p>
<p>14）Scrapy</p>
<p>地址：<a href="https://scrapy.org" target="_blank" rel="noopener">https://scrapy.org</a></p>
<p>Scrapy 是用于从网络检索结构化数据（如联系人信息或 URL）的爬虫程序（也称为 spider bots）的库。它是开源的，用 Python 编写。它最初是为 scraping 设计的，正如其名字所示的那样，但它现在已经发展成了一个完整的框架，可以从 API 收集数据，也可以用作通用的爬虫。</p>
<p>该库在接口设计上遵循著名的 Don』t Repeat Yourself 原则——提醒用户编写通用的可复用的代码，因此可以用来开发和扩展大型爬虫。</p>
<p>Scrapy 的架构围绕 Spider 类构建，该类包含了一套爬虫所遵循的指令。</p>
<p>15）Statsmodels</p>
<p>地址：<a href="http://www.statsmodels.org" target="_blank" rel="noopener">http://www.statsmodels.org</a></p>
<p>statsmodels 是一个用于 Python 的库，正如你可能从名称中猜出的那样，其让用户能够通过使用各种统计模型估计方法以及执行统计断言和分析来进行数据探索。</p>
<p>许多有用的特征是描述性的，并可通过使用线性回归模型、广义线性模型、离散选择模型、稳健的线性模型、时序分析模型、各种估计器进行统计。</p>
<p>该库还提供了广泛的绘图函数，专门用于统计分析和调整使用大数据统计数据的良好性能。</p>
<p>结论</p>
<p>这个列表中的库被很多数据科学家和工程师认为是最顶级的，了解和熟悉它们是很有价值的。这里有这些库在 GitHub 上活动的详细统计：</p>
<p><img src="/images/139.jpg" alt="&quot;language”"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/IT/">IT</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AI" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/04/AI/" class="article-date">
      <time datetime="2018-05-04T06:04:54.000Z" itemprop="datePublished">2018-05-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/04/AI/">人工智能简史</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><img src="/images/123.jpg" alt="&quot;AI”"><br>人工智能的定义可以分为两部分，即“人工”和“智能”。“人工”比较好理解，争议性也不大。有时我们会要考虑什么是人力所能及制造的，或着人自身的智能程度有没有高到可以创造人工智能的地步，等等。但总的来说，“人工系统”就是通常意义下的人工系统。<br>关于什么是“智能”，就问题多多了。这涉及到其它诸如意识（consciousness）、自我（self）、思维（mind）（包括无意识的思维）等等问题。人唯一了解的智能是人本身的智能，这是普遍认同的观点。但是我们对我们自身智能的理解都非常有限，对构成人的智能的必要元素也了解有限，所以就很难定义什么是“人工”制造的“智能”了。因此人工智能的研究往往涉及对人的智能本身的研究。其它关于动物或其它人 造系统的智能也普遍被认为是人工智能相关的研究课题。<br>人工智能目前在计算机领域内，得到了愈加广泛的重视。并在机器人，经济政治决策，控制系统，仿真系统中得到应用。“人工智能”一词最初是在1956年达特茅斯（Dartmouth）学会上提出的。从那以后，研究者们发展了众多理论和原理，人工智能的概念也随之扩展。人工智能是一门极富挑战性的科学，从事这项工作的人必须懂得计算机知识，心理学和哲学。人工智能是包括十分广泛的科学，它由不同的领域组成，如机器学习，计算机视觉等等，总的说来，人工智能研究的一个主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作。但不同的时代、不同的人对这种“复杂工作”的理解是不同的。例如繁重的科学和工程计算本来是要人脑来承担的, 现在计算机不但能完成这种计算, 而且能够比人脑做得更快、更准确, 因之当代人已不再把这种计算看作是“需要人类智能才能完成的复杂任务”, 可见复杂工作的定义是随着时代的发展和技术的进步而变化的, 人工智能这门科学的具体目标也自然随着时代的变化而发展。它一方面不断获得新的进展, 一方面又转向更有意义、更加困难的目标。目前能够用来研究人工智能的主要物质手段以及能够实现人工智能技术的机器就是计算机, 人工智能的发展历史是和计算机科学与技术的发展史联系在一起的。除了计算机科学以外, 人工智能还涉及信息论、控制论、自动化、仿生学、生物学、心理学、数理逻辑、语言学、医学和哲学等多门学科。<br>在定义智慧时，英国科学家图灵做出了贡献，如果一台机器能够通过称之为图灵实验的实验，那它就是智慧的，图灵实验的本质就是让人在不看外型的情况下不能区别是机器的行为还是人的行为时，这个机器就是智慧的。不要以为图灵只做出这一点贡献就会名垂表史，如果你是学计算机的就会知道，对于计算机人士而言，获得图灵奖就等于物理学家获得诺贝尔奖一样，图灵在理论上奠定了计算机产生的基础，没有他的杰出贡献世界上根本不可能有这个东西，更不用说什么网络了。<br>科学家早在计算机出现之前就已经希望能够制造出可能模拟人类思维的机器了，在这方面我希望提到另外一个杰出的数学家、哲学家布尔，通过对人类思维进行数学化精确地刻画，他和其它杰出的科学家一起奠定了智慧机器的思维结构与方法，今天我们的计算机内使用的逻辑基础正是他所创立的。<br>我想任何学过计算机的人对布尔一定不会陌生，我们所学的布尔代数，就是由它开创的。当计算机出现后，人类开始真正有了一个可以模拟人类思维的工具了，在以后的岁月中，无数科学家为这个目标努力着，现在人工智能已经不再是几个科学家的专利了，全世界几乎所有大学的计算机系都有人在研究这门学科，学习计算机的大学生也必须学习这样一门课程，在大家不懈的努力下，现在计算机似乎已经变得十分聪明了，刚刚结束的国际象棋大赛中，计算机把人给胜了，这是人们都知道的，大家或许不会注意到，在一些地方计算机帮助人进行其它原来只属于人类的工作，计算机以它的高速和准确为人类发挥着它的作用。人工智能始终是计算机科学的前沿学科，计算机编程语言和其它计算机软件都因为有了人工智能的进展而得以存在。<br>现在人类已经把计算机的计算能力提高到了前所未有的地步，而人工智能也在下世纪领导计算机发展的潮头，现在人工智能的发展因为受到理论上的限制不是很明显，但它必将象今天的网络一样深远地影响我们的生活。让我们顺着人工智能的发展来回顾一下计算机的发展，在1941年由美国和德国两国共同研制的第一台计算机诞生了，从此以后人类存储和处理信息的方法开始发生革命性的变化。第一台计算机的体型可不算太好，它比较胖，还比较娇气，需要工作在有空调的房间里，如果希望它处理什么事情，需要大家把线路重新接一次，这可不是一件省力气的活儿，把成千上万的线重新焊一下我想现在的程序员已经是生活在天堂中了。<br>终于在1949发明了可以存储程序的计算机，这样，编程程序总算可以不用焊了，好多了。因为编程变得十分简单，计算机理论的发展终于导致了人工智能理论的产生。人们总算可以找到一个存储信息和自动处理信息的方法了。<br>虽然现在看来这种新机器已经可以实现部分人类的智力，但是直到50年代人们才把人类智力和这种新机器联系起来。美籍俄裔数学家、控制论的创始人诺伯特·维纳（Norbert Wiener）在反馈理论上的研究最终让他提出了一个论断，所有人类智力的结果都是一种反馈的结果，通过不断地将结果反馈给机体而产生的动作，进而产生了智能。我们家的抽水马桶就是一个十分好的例子，水之所以不会常流不断，正是因为有一个装置在检测水位的变化，如果水太多了，就把水管给关了，这就实现了反馈，是一种负反馈。如果连我们厕所里的装置都可以实现反馈了，那我们应该可以用一种机器实现反馈，进而实现人类智力的机器形式重现。这种想法对于人工智能早期的有着重大的影响。<br>在1955的时候，美国计算机科学家艾伦·纽威尔(Allen Newell)和赫伯特·西蒙(Herbert A.Simon)The Logic Theorist程序，它是一种采用树形结构的程序，在程序运行时，它在树中搜索，寻找与可能答案最接近的树的分枝进行探索，以得到正确的答案。这个程序在人工智能的历史上可以说是有重要地位的，它在学术上和社会上带来的巨大的影响，以至于我们现在所采用的方法思想方法有许多还是来自于这个50年代的程序。<br>1956年，“人工智能之父”和LISP语言的发明人(ZT) 约翰·麦卡锡（John McCarthy）召集了一次会议来讨论人工智能未来的发展方向。从那时起，人工智能的名字才正式确立，这次会议在人工智能历史上不是巨大的成功，但是这次会议给人工智能奠基人相互交流的机会，并为未来人工智能的发展起了铺垫的作用。在此以后，工人智能的重点开始变为建立实用的能够自行解决问题的系统，并要求系统有自学习能力。在1957年，艾伦·纽威尔和赫伯特·西蒙又开发了一个程序称为General Problem Solver(GPS)，它对维纳的反馈理论有一个扩展，并能够解决一些比较普遍的问题。别的科学家在努力开发系统时，麦卡锡创建了表处理语言LISP，直到现在许多人工智能程序还在使用这种语言，它几乎成了人工智能的代名词，到了今天，LISP仍然在发展。<br>在1963年，麻省理工学院受到了美国政府和国防部的支持进行人工智能的研究，美国政府不是为了别的，而是为了在冷战中保持与苏联的均衡，虽然这个目的是带点火药味的，但是它的结果却使人工智能得到了巨大的发展。其后发展出的许多程序十分引人注目，SHRDLU是维诺格拉德(T.Winograd)于1972年在美国麻省理工学院建立了一个用自然语言指挥机器人动作的系统。在这个大发展的60年代，STUDENT系统可以解决代数问题，而SIR(Selective Integrated Rail)系统则开始理解简单的英文句子了，SIR的出现导致了新学科的出现：自然语言处理。在70年代出现的专家系统成了一个巨大的进步，他头一次让人知道计算机可以代替人类专家进行一些工作了，由于计算机硬件性能的提高，人工智能得以进行一系列重要的活动，如统计分析数据，参与医疗诊断等等，它作为生活的重要方面开始改变人类生活了。在理论方面，70年代也是大发展的一个时期，计算机开始有了简单的思维和视觉，而不能不提的是在70年代，另一个人工智能语言Prolog语言诞生了，它和LISP一起几乎成了人工智能工作者不可缺少的工具。不要以为人工智能离我们很远，它已经在进入我们的生活，模糊控制，决策支持等等方面都有人工智能的影子。让计算机这个机器代替人类进行简单的智力活动，把人类解放用于其它更有益的工作，这是人工智能的目的，但我想对科学真理的无尽追求才是最终的动力吧。　</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/AI/">AI</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/人工智能/">人工智能</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-从Intel和ARM争霸战，看看做芯片有多难" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/28/从Intel和ARM争霸战，看看做芯片有多难/" class="article-date">
      <time datetime="2018-04-28T01:09:24.000Z" itemprop="datePublished">2018-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/28/从Intel和ARM争霸战，看看做芯片有多难/">从Intel和ARM争霸战，看看做芯片有多难</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>从Intel和ARM争霸战，看看做芯片有多难</p>
<p>x86生态系统</p>
<p>如今Intel在服务器市场占有率近乎100%，在桌面市场也大于80%，再加上Intel一贯重视宣传，在普通大众的心目中，Intel就是芯片的代称，甚至是高科技的代称。但Intel并非生而如此，它的牛X千真万确是熬出来的，是在列强环伺的竞争环境中杀出来的。</p>
<p>称王</p>
<p>七十年代，在搭上IBM PC这趟快车之前，Intel的8位处理器已经很成功，但也有很多竞争者，Zilog是其中翘楚，它研发的Z80系列产品和Intel的8080兼容，性价比高。一直到90年代，中国很多大学的微机实验课，还在用Zilog的板子。当时还有一款处理器风头不逊于8080系列，即MOS公司的6502。后来MOS把6502的ISA（指令集架构）授权给了众多厂商，流传甚广。70年代苹果创立之初的Apple-I和Apple-II，80年代任天堂的红白机，90年代初的小霸王学习机，90年代末的文曲星，都使用了6502系列的CPU。</p>
<p>IBM PC给了Intel和微软大发展的机会。但它俩必须面对竞争。IBM PC是IBM主导下的一个开放标准，各个零部件都是可以替换的。所以才有了“兼容机”的概念，和延续至今的装机市场。当时IBM要求Intel必须把x86指令集授权给其它厂商，避免CPU供应商一家独大。IBM自己也有生成x86兼容CPU的权力。同时，为了限制微软的MS-DOS，IBM自己也做DOS操作系统，名为PC-DOS。</p>
<p>在IBM PC阵营内部，Intel面对其它CPU供应商的竞争，在阵营外部，还要和苹果的Macintosh电脑竞争。当时苹果已经换用Motorola 68000系列CPU，性能强劲，图形界面诱人。当时用Mac的人，逼格要高于用IBM PC的人。</p>
<p>Intel顶着阵营内外的竞争压力，苦心孤诣地发展壮大。这时候潜在的威胁在慢慢酝酿。从1981年的RISC-I开始，精简指令集（RISC）逐步流行起来，诞生了一系列RISC风格的CPU：1985年MIPS公司推出第一款商用的RISC芯片，HP公司在1986年推出PA-RISC，SUN公司在1987年推出SPARC，Motorola在1988年推出MC88000。当时大家普遍认为RISC优于以x86为代表的CISC风格CPU，就连Intel和AMD也害怕在RISC潮流中落伍，AMD在1987年推出了AM29000，Intel在1988年推出了i860/i960。</p>
<p>开始时RISC似乎并没有威胁到桌面市场，MIPS、PA-RISC、SPARC全是用来做服务器和工作站的。被苹果流放的乔布斯用MC88000系列CPU做NeXT桌面电脑，铩羽而归。1986年，英国的Acorn公司推出了一款名为ARM的RISC处理器，次年，它还配了个操作系统叫RISC OS，强攻桌面市场，可惜最终只在英国掀起来了一些波澜。</p>
<p>1991年，RISC阵营实实在在地杀入桌面市场。这一年，IBM看到在PC阵营里，Intel和微软这两个小弟坐大，慢慢不受自己的控制，索性拉拢Apple和在RISC市场不得志的Motorola，推出了PowerPC架构，由IBM和Motorola生产芯片，Apple做操作系统和整机，推出全新的Power Macintosh电脑。这三家组成了AIM（Apple-IBM-Motorola）联盟，气势汹汹地向Wintel联盟发起攻击。</p>
<p>结果是Wintel赢了，个中原因众说纷纭。有人说Wintel保持对已有软件的向下兼容，而Apple频繁更换底层的CPU，导致的不兼容气走了用户，然后由此强调软件生态的重要。我则以为，历史的发展有一定的偶然性，如果当时Wintel不是比尔盖茨和格鲁夫在掌舵，而Apple是乔布斯在掌舵，可能结局完全不同。2005年，乔布斯掌舵下的苹果，把Mac里面的CPU由PowerPC换成Intel的芯片，就完成得干脆利落，没怎么受到软件生态的牵绊。</p>
<p>总之，在80年代，大家就已经深深懂得CPU的ISA是软件生态系统的根基，不愿让这个“生态之根”被别人控制。整机和系统的制造商，通过强制CPU厂商给其它厂商授权自己的ISA，来保证有第二家甚至更多的供应商。如果不慎“生态之根”被别人控制了，例如IBM被Wintel篡了权，甚至不惜另起炉灶来竞争。</p>
<p>同样是把自己的指令集授权给其它厂商，Intel把几乎所有的其它供应商都挤死了，只省下AMD苟延残喘；MOS则销声匿迹了，完全靠其它生产商把6502系列延续到了二十一世纪。造成这一差异的原因纵有千万条，我想“打铁还需自身硬”是最根本的。</p>
<p>霸业</p>
<p>在桌面市场上，Windows 95和Windows 98这两款操作系统，让Wintel联盟登上了霸业的顶端。从1995年到2003年，Intel看起来简直是不可战胜的。</p>
<p>与此同时，Intel还把几乎所有的RISC架构的CPU都干趴下了，占领了服务器市场。原因大概有这么几点。</p>
<p>第一，从技术角度讲，RISC是一种设计CPU的理念，而不是具体的某一种ISA。像x86这样的复杂指令集，其实在实现过程中，也能借重RISC的理念。1989年的80486，已经隐隐地可以看到RISC风格的流水线，1995年的Pentium Pro，其核心已经是一个乱序执行的RISC了，只不过多了一个复杂的译码逻辑，把x86指令拆分成RISC风格的微操作。因此从技术角度讲，RISC指令集未必比x86有优势。</p>
<p>第二，RISC成也UNIX，败也UNIX。UNIX和C语言树立了很好的软件开发传统，确保同一套代码可以很方便地在不同CPU之间移植。80年代，一大堆RISC架构的CPU，都可以很快配上自己的UNIX，很快把已有的C语言编写的应用跑在CPU上，然后就可以卖了。SUN公司的SPARC配有Solaris，HP公司的PA-RISC配有HP-UX，IBM公司的PowerPC配有AIX。这些林林总总的UNIX变体，反过来又进一步促使UNIX生态系统中软件开发人员重视代码的可移植性，大家都很小心地围绕POSIX标准来编程，避免过分依赖于某个操作系统独有的功能。这样，一旦Intel芯片携Linux（一种开源的UNIX变体）来和RISC架构的工作站竞争，软件应用就纷纷以很小的移植难度，离开了昂贵的专有UNIX工作站。</p>
<p>第三，当时PC市场比服务器市场大得多，Intel在PC市场的盈利帮助它研发更好的服务器芯片，巨大的出货量降低了芯片的制造成本。研发优势和成本优势，奠定了Intel最终胜利的基础。</p>
<p>这段时间，Intel还几次面临挑战，每次都成功保卫了自己对于生态系统的掌控权。</p>
<p>第一个挑战，来自Internet浏览器。Netscape Navigator诞生后，对微软和Intel都是挑战。虽然当时的动态网页还非常初级，但是已经有人喊出“Web is the computer”的概念。等到Java Applet出现之后，大家更是觉得可以在网页上实现桌面应用的效果，未来只需一个浏览器，就能取代桌面。Netscape的Marc Andreessen在1995年，就着手把Netscape浏览器打造成一个Internet OS[5]。以那个时代的软硬件水平，毫无疑问地，这些尝试失败了。</p>
<p>用一个高层次的软件API，兜住所有的上层应用，然后让底层的硬件，都来支持这个API——这个主意不单单在技术上看起来很炫，从商业上，这是上层应用厂商消解底层平台厂商生态霸权的终极武器。因此，在那之后的二十年里，商业上的尝试一直在持续，包括：</p>
<p>腾讯开发的WebQQ和Q+，在网页里面提供一个类似Windows桌面的应用场景，后来失败了，回退到功能单一的SmartQQ。个中原因，我个人认为还是那个时代的PC性能不够。</p>
<p>腾讯开发的微信小程序，在微信里面通过HTML5和Javascript实现手机App的功能，可以横跨iOS和Android。</p>
<p>谷歌推出ChromeOS和ChromeBook笔记本，里面跑的应用，全都是基于HTML5和Javascript的。</p>
<p>我个人认为，微信小程序几乎一定会成功，它一旦成功，腾讯必然会重燃在PC平台上做Q+的野心。Intel在桌面的霸权，最大的威胁不是AMD，也不是ARM，而很可能是HTML5+Javascript，熟悉“降维打击”的人，对此不会感到意外吧。</p>
<p>第二个挑战，来自虚拟机（Virtual Machine）和JIT（Just-in-time）编译器。先锋是Java的虚拟机JVM，后来微软也推出了DotNet虚拟机，支持C#等语言。虚拟机有一套虚拟的指令集，源代码先被编译到这个虚拟的指令集上，在程序运行时，JIT编译器再把这套虚拟指令集编译为CPU的原生指令集。面向虚拟机开发的程序，例如Java Applet，可以在不同的CPU和操作系统平台上运行。</p>
<p>如果有某个虚拟机，它的指令集可以无缝支持所有的编程语言，还能保证高效率，那么所有CPU的都将被OTT（over-the-top）了，就像短信被微信OTT一样。可惜还没有一个虚拟机可以实现此目标。现在大家熟知的虚拟机，都是和语言绑定的，例如JVM只支持Java、scala、kotlin等；DotNet虚拟机只支持C#、VB.net等；V8只支持Javascript、typescript等；HHVM只支持PHP。同一个VM上跑的语言相互调用很容易，跨VM很难互操作。由于虚拟机实在太多了，它们反而成了新的CPU架构的拦路虎：80年代只需要搞定C语言编译器就能卖Unix工作站，如今ARM服务器要想挑战Intel，必须把所有这些基于VM的编程语言都支持得很好，JIT编译器的效率都要做得比较高才行。</p>
<p>第三个挑战，来自Transmeta公司对x86指令集的Emulation（Emulation这个词很难翻译，索性不翻了）。简单地说，Emulation就是把x86指令集看成一个虚拟机的指令集，然后用类似JIT编译器的技术，在非x86的CPU上跑x86的程序。未经许可用别人的ISA做CPU是违法的，但用Emulation的方式实现ISA则不违法（Intel和Transmeta只打过专利的官司没打过ISA的官司，Intel还输了）。如今最广为人知的Emulator是Qemu，上文提到的x86、MIPS、PowerPC、Sparc、MC68000它都可以支持。一般而言，Emulation会导致性能下降一个甚至若干个数量级，根本不足为虑。</p>
<p>1995年，Transmeta公司成立，经过艰苦的秘密研发，于2000年推出了Crusoe处理器，用Emulation的方式，在一款VLIW（超长指令字）风格的CPU上执行x86的程序，这样就规避了没有x86指令集授权的问题。Transmeta的牛逼在于，虽然是Emulation，但实现了接近Intel处理器的性能，同时功耗低很多。2000年年底Transmeta的IPO大获成功，其风光程度，直到后来谷歌IPO的时候才被超过。</p>
<p>Transmeta最后还是失败了，Intel在渠道上打压它是次要原因，性能不足是主要原因。虽然VLIW在90年代中后期被广为推崇，但事实证明，它的性能比起乱序执行的超标量架构，还是差一截。另外Transmeta的芯片是在台积电制造的，那个时候不比现在，台积电的工艺水平比起Intel还差很多。2000年的时候，PC还远没有性能过剩，性能还是比功耗重要。等到2010年，Intel的Atom处理器慢得一塌糊涂，依然靠着低功耗，点燃了上网本的大火。</p>
<p>Transmeta虽然失败了，Emulation技术仍然在发展。NVidia在2008年购买了Transmeta的低功耗技术的授权。2014年，NVidia推出了Tegra K1芯片，其中的Denver处理器，利用Emulation技术，在底层的7路超标量架构上，实现了ARM64指令集。值得注意的是，NVidia拥有ARM64的指令集的授权，它不是用Emulation技术来规避什么，而是用Emulation来提升性能，实现比硬件直接执行还要高的性能。根据评测结果，Denver超过了当时苹果最好的手机CPU。近期推出的Denver2处理器的，性能更是秒杀苹果的A9X和华为的麒麟950。</p>
<p>Emulation技术如果真的发展到了比直接执行还要快，Intel的麻烦才刚刚开始。微软联合高通，推出基于SnapDragon835处理器的笔记本，运行Windows 10操作系统[13]，上面可以安装x86的软件。Intel虽然很不爽，但Emulation并不需要指令集授权，所以他只能警告说，在实现Emulator时，不许侵犯Intel的专利，而这一点，微软和高通肯定早已考虑到了。</p>
<p>挫折</p>
<p>x86生态系统曾经面对过一次最严重的、近乎灭顶之灾的挑战。这次挑战来自于谁？就来自于它的缔造者Intel。</p>
<p>Intel心不甘情不愿地把自己的x86指令级授权给了AMD等一众供应商，眼睁睁看着他们分享自己的利润，很不爽，于是想在x86之外另起炉灶，建设自己独享的生态系统。正巧在90年代初期，升级64位计算成为一个风潮，1991年有MIPS R4000，1992年有DEC Alpha，1995年有SUN SPARC64。1994年开始，Intel联合HP，准备趁32位升级64位的时机，抛弃原有的x86架构，新推出一个EPIC（Explicitly Parallel Instruction Computing）架构，名为IA64（Intel Architecture 64-bit）。</p>
<p>x86架构兼容老旧应用程序的能力是出了名的。8086把8位的8080升级为16位的时候，80386升级到32位的时候，都完全兼容旧有的程序。直到今天，Intel的处理器依然支持虚拟8086模式，在此模式下，可以运行30多年前的8086程序。升级到64bit的时候，Intel居然要放弃所有之前的8位、16位、32位应用了！可想而知当时在业界会引起怎样的轩然大波。Linux的缔造者Linus Torvalds公开对此表示反对。</p>
<p>IA64进展得并不顺利，EPIC本质上就是一种VLIW，如前所述，VLIW的性能比乱序超标量要差。而且EPIC的编译器非常难以开发。原定1997年就会推出产品，但直到1999年才发布IA64指令集，2001年才推出产品[19]。另外Intel也不敢完全放弃之前的32位x86应用，它给出的解决方案是Emulation，但EPIC不像Transmeta为Emulation做了很多专门优化，跑32位x86应用的性能很差。</p>
<p>这个时候，千年老二AMD站了出来，为x86续命。2000年，它推出了AMD64指令集，延续了x86架构兼容老旧应用程序的优良传统，可以原生执行8位、16位、32位的老程序。2003年，AMD推出Opteron服务器CPU和Athlon64桌面CPU。</p>
<p>AMD64从技术上和生态上都压了IA64一头，Opteron在服务器市场上为AMD赢得了前所未有的成功。2004年，Intel推出了代号为Nocona的至强服务器CPU，它支持一种称为EM64T的技术，EM64T就是AMD64的马甲。江湖有传言说，Intel曾想提出另外一套不同于AMD64的x86升级64位的方案，但微软为了避免x86生态的分裂，极力阻止了。2012年，Intel推出了最后一代IA64的CPU，关闭了这个不赚钱的产品线。</p>
<p>回顾这段历史，有几点特别令人感慨。首先，即使是看似无比强大不可战胜的Intel，不顾生态系统中其它伙伴的利益，一意孤行也是会撞南墙的。其次，幸好由于历史的原因，x86生态中，AMD和Intel是交叉授权的关系，AMD有权加入3DNow这种多媒体扩展指令，也有权加入64位指令，如果是像如今ARM的架构级授权方式，被授权的企业不能自行加以扩展，那可能还真没有办法阻止Intel了。最后，Intel的执行力还真是超强，掉头极快，EM64T的CPU只比AMD64的CPU晚出了一年（当然不能排除Intel早就有备份方案）。</p>
<p>虽然在IA64上栽了跟头，但Intel靠着自己的技术实力，持续不断地推出性能和功耗表现更好的产品，AMD在64位战役中所取得的优势，慢慢也被消磨掉了。</p>
<p>岁月如梭。进入移动互联网和云计算时代之后，服务器的需求量上升。这时RISC架构的服务器CPU几乎快被消灭干净了，只剩下IBM Power奄奄一息。于是Intel几乎独享了服务器市场扩大所带来的红利。但它却高兴不起来，因为移动市场形成了ARM一家独大的局面，移动终端CPU这个市场，Intel怎么也挤不进去。</p>
<p>正巧Intel在刚刚火过一把的上网本市场里设计了一种低功耗的x86核心，即Atom。Intel以Atom为武器，杀入了手机芯片市场。2012年，Intel的老伙计联想，推出了第一款Intel芯片的手机K800。紧接着还有Motorola的XT890。2013年，中兴、华硕也有产品问世。但三星、小米、华为、OPPO、VIVO等出货量大的厂商，都没有采用Intel的芯片。这些手机大厂，看看x86生态中做整机的联想如何艰难度日，估计心里也是一万个不乐意让Intel到移动领域来继续称王。</p>
<p>到2014年，Intel芯的手机还是没有打开局面，市场唱衰之声一片。但Intel并不想放弃。手机攻不下，那就攻平板！大厂攻不下，那就攻白牌！嫌我的芯片贵，我就给补贴！又过了两年，平板也没有攻下来。在移动市场赔了上百亿美金的Intel，黯然离场。</p>
<p>Intel失利的原因众说纷纭，我觉得根本原因还是竞争力不足。首先，这个时候的台积电已经不是Transmeta家Crusoe芯片诞生时的吴下阿蒙，它生产的手机芯片的功耗和性能并不输给Intel；其次，这次Intel并无生态系统的优势，要靠名为houdini的Emulator来执行ARM指令集的程序，性能打了折扣。试想，Intel芯的手机如果性能和待机时间都是iPhone的两倍，谁能抵挡得住这种诱惑？</p>
<p>几乎在进攻移动市场的同时，Intel也在推出产品试水物联网市场，只不过没有大举宣传。2013年10月，Intel推出一款叫做伽利略的Arduino开发板[31]，上面的CPU叫做Quark（夸克）。Quark是比Atom（原子）还小的基本粒子，这个名字暗含着轻巧、低功耗的意思。接着，Intel在2014年的CES大会和2016年的IDF大会上，先后推出了升级的爱迪生和焦耳开发板。</p>
<p>Intel的大名和Arduino联系在一起多少有些奇怪。Arduino是一套可以跑在低端MCU上的C语言函数库，是电子创客们的最爱。淘宝上Arduino开发板才几十块钱。焦耳开发板上的处理器是4核心、1.5GHz，跑Arduino太浪费了。和它参数近似的Raspberry PI 3 Model B+开发板，四核64位ARM Cortex A53跑1.2GHz，淘宝价不到200块。焦耳开发板要369美元。谁会当这个冤大头[32]？</p>
<p>物联网市场极度分散，有无数应用但规模都不大，Intel赚大钱习惯了，在这个微利又需要贴近客户做服务的市场里，百般不适。2017年，Intel悄悄停产了针对物联网市场的开发板。</p>
<p>Intel接下来所可能面对的挫折，是ARM侵入服务器和桌面领域。这个话题下文还会有简单分析。</p>
<p>ARM生态系统</p>
<p>近几年ARM风光无限，抢新闻头条的能力不逊于Intel。在很多圈外人看来，这家高科技公司好像是在移动互联网时代新冒出来的，但其实它的历史和几乎和80286一样古老。而且它自诞生以来，就以移动（portable）设备为自己首要的目标市场。它等待一飞冲天的风口，等待了二十年。</p>
<p>发端</p>
<p>前文提到，ARM是Acorn电脑公司创造的。Acorn电脑公司创立于1978年，在80年代初，它用6502系列CPU制造的BBC Micro电脑在英国大获成功。6502的性能慢慢跟不上时代了，Acorn想基于80286开发新的电脑，但是Intel连样片都不给——要是Intel大方些，ARM或许根本就不会诞生。Acorn一气之下开发了ARM（Acorn RISC Machine），这是世界上第一款定位中低端（而非服务器）RISC处理器[35]。1985年，ARM1诞生（但从未被商用），后来Acorn在1986年和1990年分别推出了ARM2和ARM3，1987年推出了RISC OS和桌面电脑Archimedes。它在英国的教育市场获得了一定的成功，但1990年之后，很快被Wintel的生态击败了[36]。</p>
<p>1990年前后，研发掌上电脑成为一股风潮。当时有家叫做Active Book的公司，拿ARM2处理器开发一个叫做Personal Communicator的产品[37]。可惜产品上市前，Active Book被AT&amp;T收购了，AT&amp;T把ARM2换成了自家的Hobbit处理器。幸好东方不亮西方亮，当时的苹果公司看好ARM，把自己研发的Newton平台中的处理器，由AT&amp;T的Hobbit，换成了ARM。这个“彼此互换”的故事听起来让人头大，大家只需要记住，ARM的第一颗商用处理器ARM2，就曾被尝试拿来做手持的电脑。</p>
<p>ARM的东家是Acorn，和苹果在电脑市场上有竞争。苹果公司花了6周时间说服Acorn把ARM独立出来运营。1990年11月27日，合资公司ARM正式成立，苹果、Acorn和VLSI分别出资150万、150万、25万英镑，Acorn把ARM处理器相关的知识产权和12名员工放在了新成立的公司里。此后，ARM的缩写被转而解释为Advanced RISC Machine。为了节省成本，新公司在剑桥附近租了一间谷仓作为办公室，全力为苹果的Newton研发ARM6处理器（4和5这两个编号被跳过去了）。</p>
<p>Newton（牛顿）是苹果花大力气研发的触屏移动技术平台，Newton OS是不同于Mac OS的操作系统（如同后来的iOS）。如果你听过苹果、牛顿和万有引力的故事，应该能体会苹果公司对Newton平台有多么高的期望。Newton平台的第一款产品MessagePad于1993年8月上市了，采用32位ARM610处理器，频率为20MHz，屏幕大小为336×240，重量410克，采用4节7号电池供电，售价699美元（相当于今天的1129美元）。可惜的是，它销量很差，上市头四个月的销量不过5万台[38]。</p>
<p>1998年，中国的恒基伟业公司推出了一款叫做 “商务通”的产品，像极了Newton Messagepad。它采用Dragonball处理器，主频仅16MHz，屏幕大小10汉字x10汉字，重量105克，采用2节5号电池供电，售价人民币1988元。靠着“呼机手机商务通，一个也不能少”的广告，商务通在1999年大卖100万台[41]。虽然2001年后商务通及类似产品很快就被越来越强大的手机挤出了市场，但让人好奇的是，背靠营销能力更加强大的苹果，Newton为何没能一炮而红？</p>
<p>其中一个重要的原因是，Newton重点宣传的手写识别功能表现很糟糕。而商务通对手写汉字的识别率——根据我个人的体验——还真是不错，考虑到它仅仅16MHz的CPU主频，能做到这么好简直是奇迹。当时商务通部分型号的卖点就是“连笔王”[42]，对潦草的汉字识别得相当好。</p>
<p>软件对于一款产品的重要性，真的是生死攸关啊！</p>
<p>深耕</p>
<p>扯远了，让我们回到ARM的故事上来。</p>
<p>1990年ARM创立之初，给自己定下的使命是“设计有竞争力的、低功耗、高性能、低成本的处理器，并且使它们成为目标市场中广为接受的标准”，目标市场包括：手持设备（Portable），嵌入式（Embedded Control）和汽车电子（Automotive）。跨越近三十年，这个使命和市场定位始终未变，直到今天。</p>
<p>而且，根据我了解到的知识，ARM是处理器的源代码授权这一商业模式的开创者。如今，芯片设计从Verilog等源代码出发，经过一系列自动化或半自动化的优化步骤，最终形成工厂制造芯片所需要的版图文件；整个过程类似软件从源代码被编译为CPU的机器码。但在80年代，芯片的设计自动化非常原始。七八十年代的处理器授权，都是指令集的授权。Synopsys公司于1986年成立，1987年推出把Verilog编译为门级网表的DesignCompiler[43]，之后基于源代码的芯片自动化设计流程才慢慢地被建立起来。于是源代码授权才成为技术上可行的模式。</p>
<p>ARM从未自己生产过商用的芯片。它只是将自己研发的处理器的源代码的知识产权（IP）授权给芯片厂商，由它们推出最终芯片。受益于这一商业模式，尽管在1993年，Apple的Newton失败了，但ARM并未因为设备卖不出去而亏钱，还幸运地拿到了TI的订单[44]，于是成功盈利了。员工数量也由12人增长到了42人。次年ARM又拿到了三星的订单，员工增长到70多人，搬出了谷仓。除了源代码授权的模式之外，ARM也做指令集授权，1995年，ARM把指令集授权给DEC，DEC很快设计出了性能更好的StrongARM处理器。1997年，StrongARM产品线被卖给Intel，更名为XScale。</p>
<p>1995年，Motorola在香港的研发团队基于MC68000指令集开发出了针对手持设备的DragonBall处理器，在这之后的十年，DragonBall处理器一直都是ARM强大的竞争对手[46]。不但Moto自己的手机用它，Palm、三星、Sony的手机也用它。当然还有前文提到的商务通。ARM相对于Dragonball处理器有什么优势？我认为最大的优势是从客户需求出发的、持续的创新；其次是ARM的开放的商业模式。</p>
<p>RISC指令集一般都采用32位定长指令，代码密度比起x86之类的CISC来要差一些，但手机的存储空间有限，对代码密度的要求高。1994年，ARM为此专门研发了16位的指令集Thumb，以及支持这一指令集的ARM7TDMI[47][48]。</p>
<p>开放授权的商业模式，使得整机厂在选择芯片时，可以找到支持同一指令集的多种芯片产品，不容易被绑架。Nokia作为和Motolora旗鼓相当的手机制造商，肯定不会选择竞争对手的Dragonball，而ARM的技术实力和商业模式，正好符合Nokia的需求。</p>
<p>1997年，Nokia推出了一代经典6110，它采用TI的芯片，处理器核心是ARM7TDMI。6110是Nokia第一款带红外接口的手机，第一次内置了经典的贪吃蛇游戏，它的界面成为了之后Nokia手机的标准。从此，Nokia和ARM成为了好基友，Nokia的Symbian操作系统，一直都建立在ARM架构的基础上[53]。</p>
<p>1998年，趁着6110大红大紫的东风，ARM在Nasdaq上市了。同一年，SGI公司看到处理器IP授权生意有利可图，把MIPS部门拆分出来，次年MIPS推出了它第一款可授权的处理器设计M4K[54]。此后的十年里，MIPS一直都是ARM有力的竞争对手[55]。</p>
<p>商务通在中国流行的那几年，国际市场上流行性能更高的掌上电脑和智能手机，操作系统包括Palm OS、微软的WinCE、Nokia的Symbian、RIM的Blackberry OS，Motorola的Wisdom OS。在这个领域里，ARM阵营中负责高性能的XScale大放异彩，暴击Dragonball。当Dragonball的频率还停留在33MHz/66MHz时，Xscale已经飙到了200~400MHz。MC68000指令集在手持设备领域败走。Palm OS的1.0~4.0都是基于MC68000指令集的，5.0就换成了ARM。后来Motorola的半导体部门Freescale干脆推出了基于ARM核的iMX系列产品，替代Dragonball产品线。</p>
<p>苹果作为掌上电脑的先行者，却在这次浪潮里无所作为，在Wintel的挤压下，它的桌面业务都已经濒临绝境，无暇顾及其它市场了。1997年，不温不火的Newton从苹果公司独立了出来。当乔布斯回归苹果之后，又火速把Newton收编了回来，并且干净利落地停掉了Newton产品线——乔帮主只想要Newton手里的ARM股份。1998年到2003年，苹果通过出售ARM的股票获利11亿美元。这笔钱，是乔布斯复兴战略的重要燃料，可以说是苹果的救命钱[56][57]。</p>
<p>绽放</p>
<p>经过多年的深耕，ARM在新世纪开始时，已经是手机领域里的王者，依然在为客户的需求做着持续的创新，Java加速技术就是一个典型的例子。</p>
<p>从2000年开始，功能手机的性能提升到了足够高的水平，人们希望在手机上玩比较复杂的游戏，而不仅仅是贪吃蛇。但是手机的处理器和操作系统实在是太分散了，为了方便游戏跑在不同手机上，J2ME平台应运而生[58]。从原理上讲，J2ME和Applet并无不同，都是基于JVM的。Java在并不分散的桌面领域没有获得成功，但在分散的手机领域获得了成功。</p>
<p>J2ME的游戏越做越复杂，但手机的处理能力毕竟有限，桌面和服务器上的JIT编译器在手机上跑得太吃力了。于是ARM在2001年推出了ARM926EJ-S处理器，它支持Jazelle DBX技术，可以直接解码和执行Java的字节码，省掉了JIT编译器的负担[59][60]。这一功能大受欢迎，帮助ARM9系列成为了迄今最受欢迎的ARM处理器，总共有250多个授权厂家，其中100多个授权的是ARM926EJ-S[61]。</p>
<p>在MTK助推山寨功能机火遍神州的那几年，主控芯片所使用的核全部都是ARM9[62]。在iOS和安卓的应用商店诞生之前，功能手机全靠J2ME开发的应用来实现各种炫酷的功能。从某种意义上讲，在低端市场上，Jazelle是助力山寨机火爆的最大幕后功臣。</p>
<p>然而高性能ARM芯片的扛把子XScale，却被Intel于2006年6月卖给了Marvell。这是Intel实施x86-everywhere战略的一个步骤。Intel希望x86的生态也能进入到低功耗的移动领域，而不是用自己先进的工艺制程和设计能力帮ARM建设高端应用的生态。22个月之后，2008年4月，低功耗的Atom芯片诞生了[63]。</p>
<p>高性能ARM芯片的扛把子换成了苹果。2004年，在卖光ARM股票的一年之后，乔布斯决定研发iPhone。2007年1月，在Intel放弃ARM之后仅半年，iPhone诞生了。苹果可不会采用低端市场上死守ARM9那种玩法，iPhone一代就采用了400MHz的ARM11；2009年的iPhone 3GS，升级为600MHz的Cortex A8；2010年的iPhone4，苹果自研的A4芯片升级为1GHz的Cortex A8。接下来苹果自研芯片性能一路狂飙的历程，大家都很熟悉了。</p>
<p>从ARM6到ARM11，这些IP核都是按照兼顾移动设备、汽车电子和嵌入式这三个市场的思路来设计的。从2003年起，ARM把产品线有针对性地划分为A、R、M三个系列，分别对应上述三个市场，而且IP核的名字都统一加上了Cortex的前缀。Cortex A8就是A系列的第一个作品。iPhone 3GS和iPhone4令Cortex A8大火，但让ARM一飞冲天的推手，却是iPhone的竞争对手——安卓（Android）。</p>
<p>有很多文章介绍安卓如何诞生，如何在移动设备领域干掉了除iOS之外的全部对手，毋须赘述。这里只想强调一个被普遍忽略的事实：安卓从诞生之初，就要求应用程序采用Java编写，并且跑在Dalvik虚拟机上；但iPhone上的应用，都是原生的ARM程序。要知道Android手机的处理器性能相对iPhone并无优势。山寨之王MTK于2009年2月推出的首款智能手机芯片MT6516，采用406MHz的ARM9；2008年~2010年间由HTC推出的那几款卖得很好的Android手机，也无非是ARM11和Cortex A8的核，几百兆的频率，这种级别的处理器跑虚拟机还是蛮吃力的。另外虚拟机占用内存大的缺点，也不利于用户体验和降低成本。</p>
<p>谷歌宁可冒着让安卓出师不利的风险，也要推广Dalvik虚拟机。这是为什么？谷歌内部的决策过程我们无从得知。一个合理的猜测是，谷歌不愿看到手机领域里ARM一家独大，它希望给MIPS、x86等其它CPU一个机会。J2ME的成功，让谷歌看到完全建立在虚拟机上的手机应用生态，是完全可能的。Dalvik虚拟机可以跑Java，但并不采用JVM那种基于堆栈的字节码，而是改用一种基于寄存器的方案。这么做当然是为了规避SUN公司（后被Oracle收购）的专利，同时也让无法直接运行JVM字节码的MIPS、x86能够实现轻量级的JIT编译器，无须Jazelle这样的技术。从另外一个角度讲，MIPS在电视、机顶盒、游戏机市场上占优，x86在桌面市场近乎垄断，支持它们，也意味着安卓有可能进军电视和桌面。</p>
<p>安卓对所有CPU而言，都是巨大的机会，谁抓住了这个机会，就可以一举改变竞争格局，实现霸业。</p>
<p>只可惜MIPS公司太不给力，一直也没有搞定靠谱的MIPS版Android。等到2011年1月，Synopsys公司给自家的ARC处理器移植好Dalvik虚拟机和浏览器用的V8虚拟机[65][66]、Android环境已完备的时候，MIPS都还没动静。顺便说一句，Intel曾经的南桥芯片里都有ARC处理器，它是Active Management Technology（AMT）的重要基石。</p>
<p>这个时候，北京的君正公司坐不住了。君正靠做低成本的MP4播放器起家，2011年5月在创业板上市。君正拥有MIPS的架构级授权，对自己研发的XBurst处理器非常自信，准备靠它进攻手机和平板市场。2011年7月，基于君正JZ4760的MIPS智能手机通过Android兼容性测试。2011年12月，基于君正JZ4770平台的平板电脑，被谷歌选为Android4.0的首发产品，一时风光无限[71][72][73]。</p>
<p>ARM的强大软件生态此时起到了护城河的作用。基于君正的平板，软件兼容性出了问题。原因在于谷歌没有强求所有的应用都跑在Dalvik虚拟机上，对于部分对性能有苛刻要求的app，例如游戏，谷歌允许用CPU的原生指令集来开发，为此还提供了NDK（Native Development Kit）。对于那些包含了ARM原生指令的游戏，君正的平板要么不支持，要么用emulator支持，总之用户体验都不好。</p>
<p>ARM生态圈里，在2011年，正好有两家芯片厂商异军突起：全志和瑞芯微，它们分别推出了采用Cortex A8处理器的A10芯片和RK2918芯片，成本极低，主打平板和安卓电视盒子。君正的平板梦被它们粉碎了，之后只好转战安卓手表，消沉了很多年。对于MIPS而言，还有一个坏消息是，在它们的强力助推下，电视盒子市场也成了ARM的天下。经营不善的MIPS于2012年卖给了Imagination[74]，Imagination不但没能依靠MIPS在CPU市场中有所作为，反而在GPU市场里也败给了ARM，在2017年被迫整体卖身，MIPS业务卖回给了硅谷公司。</p>
<p>2012~2016年，Intel在安卓市场上挑战ARM，也失败了。于是安卓给CPU带来的红利，全部被ARM吃掉了。随着手机越来越重要，ARM也越来越重要，它所推出的最新的Cortex A系列处理器，被手机芯片争相采用。ARM生态也越来越强大，它的触角，慢慢伸出了手机领域。</p>
<p>渗透</p>
<p>2011年1月，微软在CES宣布要为ARM架构开发Windows 8 RT操作系统。在2012年年底，几乎和Intel芯手机上市的同时，包括微软自家的Surface RT在内的一大批二合一平板设备上市了。Windows 8 RT不支持所有之前为x86平台开发的应用程序，这成为它最大的软肋，相关的产品慢慢销声匿迹了。ARM渗透桌面市场的第一次尝试失败了。</p>
<p>最近微软和高通所推出的ARM芯的Windows 10，吸取了教训，用Eumlation的机制来支持旧有的x86桌面程序。这次尝试能否成功，我们拭目以待。</p>
<p>2009年，ARM推出了Cortex A9处理器，并且用40nm的工艺制造了双核的样片，跑到了2GHz。这是ARM第一次推出乱序超标量的处理器核，而乱序超标量是Intel实现高性能的关键技术，这是非常振奋人心的消息。2010年，Marvell推出了1.6GHz的4核A9的服务器芯片Armada XP。2013年，这款芯片被部署在百度的存储服务器上，这是ARM服务器第一次大规模商用。但Marvell并未继续推出新的服务器芯片。2011年，一家创业公司Calxeda采用Cortex A9，推出了共有480个CPU核的ARM服务器。但它的成就还不如Armada XP，2013年公司就倒闭了。</p>
<p>2012年，AMD收购了一家做高密度服务器的厂商SeaMicro，准备把它所采用的CPU核由Intel的Atom换成ARM架构的CPU。但直到2014年AMD才推出8核Cortex A57的服务器芯片Opteron A1100[82][83]，之后从来也没有认真卖过它。2015年AMD就放弃了SeaMicro这个子品牌，不再做高密度服务器了。</p>
<p>ARM进攻服务器市场的第一次尝试失败了。Marvell和Calxeda都采用的是32位的ARM核，先天不足；AMD则三心二意，毕竟自己还有x86 Server的生意。另外服务器市场对于单核单线程的运算能力也有很高的要求，仅仅有低功耗和高通量（high throughput）是不够的。</p>
<p>在ARMv8这一64位指令集发布之后，Cavium和AppliedMicro这两家老牌网络芯片厂商不约而同地将自己原先芯片中的架构换成了ARMv8[85][86]。因为产品的需要，Cavium和AppliedMicro都有自行设计处理器微架构的能力，前者做MIPS处理器，后者做PowerPC处理器。它们两家做ARMv8处理器时，也都采用了只授权指令集，微架构自研的模式。Cavium共推出过两代基于ARM的产品（2014、2016年），AppliedMicro推出过三代（2013、2015、2017年）。随着产品性能逐渐接近Intel的Xeon E5[87][88]，它们渐渐不再满足于原先的网络领域，开始觊觎服务器市场。</p>
<p>最让人期待的还是高通的Centriq芯片，2015年年底量产24核版本，2016年年底量产升级48核版本，还得到了微软的强力支持。考虑到高通还和贵州成立了合资公司华芯通[91]，Centriq很可能成为在国内大规模商用的第一款ARM服务器芯片。</p>
<p>另外具有国防背景的天津飞腾公司，也有ARM服务器芯片的产品，只是不知道这些产品何时能在通用市场上铺货。</p>
<p>其他确定在研发ARM Server芯片的大厂还包括Broadcom和华为，进度上要略慢一些。</p>
<p>ARM阵营对服务器发起的第二波冲击，阵容要强大得多豪华得多。因此ARM才敢于宣称，在2021年拿下25%的服务器市场份额[95]。</p>
<p>要做好Server CPU，ARM架构还有些功课要一点一点补。多Socket服务器所需要的一致性协议，业界刚刚取得共识准备采用CCIX[96]，但还没有具体的产品出来。做云端虚拟机所必备的虚拟化支持，ARM还有些性能问题[97]。x86处理器提升Throughput的利器超线程技术，ARM阵营尚不能支持。Intel芯片近年来陆续增加的安全特性[98][99][100][101]，也够ARM追赶一阵子的。但目前看来，ARM已经没有致命的短板，蚕食掉Intel的服务器市场份额是板上钉钉的事情，唯一的悬念是究竟多少份额？</p>
<p>未来ISA将不那么重要</p>
<p>从长远看，半导体厂商对建立于ISA之上的生态系统的掌控力会变弱，而ISA本身，会变得越来越不重要。这是软件技术发展的趋势决定的，如前所述，这些技术在90年代末就已经初有小成了。</p>
<p>第一是Web技术。网页开发领域，有一个大家视若无睹的奇迹：最后居然只有Javascript一种开发语言屹立至今。要知道在服务器端和移动App领域，开发语言多如过江之卿。其中原因我也分析不出。反正js的挑战者（微软的VBScript和谷歌的Dart）都失败了。网页开发领域面临的主要问题是浏览器差异大，API不太兼容。这个问题慢慢在缓解中，一来浏览器战争大局已定，Android和PC上的Chrome，以及iPhone和Mac上的safari是胜者；二来很多网页应用是跑在App里面的，例如微信和支付宝里，这种场景下Javascript的API已经被特定厂商规范过了。</p>
<p>由于开发语言和API的高度统一，H5（HTML5+Javascript）已经成了兼容所有硬件的最通用的软件开发平台。曾经有人鼓吹H5会赶走移动端和PC端的原生程序，后来被打脸了。但是移动端和PC端的原生App中，越来越多的界面是用H5生成的了，微信、支付宝、京东、淘宝、爱奇艺、有道词典……，统统都是这样。</p>
<p>Javascript吞噬一切的进程还在持续。2007年，Stack Overflow的联合创始人Jeff Atwood曾经提出过一条Atwood定律[102][103]：任何能够用JavaScript实现的应用系统，最终都必将用JavaScript实现。十年过去了，此定律基本奏效。把Javascript的一个子集当作汇编语言的asm.js及其后续的WebAssembly，更加使得网页应用有媲美原生应用的潜力，在浏览器里跑Unity3D的游戏都不是问题。</p>
<p>独立的应用程序仍然会是移动和桌面端的主流，因为没有独立程序，不方便做弹窗广告，不方便启动后台进程收集用户信息，不方便引诱用户安装其它独立程序。但Web的能力的确在快速提升，Web Component技术实现了类似GUI库的Widget复用，如今在浏览器里实现Office和IDE的功能都毫无问题（office365.com、docs.google.com、editor.construct.net、腾讯文档[104]）；而WebGL已经能支持Unity3D这种大型游戏框架。照此趋势发展下去，独立应用程序仅仅会作为一个包装而存在，开发者写一套H5，加上不同的包装，就成了PC、Mac、Android、iOS上的独立应用程序，不加包装，就是网站。微软去年开源的ReactXP[105]，就是为了实现这一目标。</p>
<p>这意味着什么？不但底层的CPU被OTT了，操作系统也被OTT了。因为移植一个应用程序到各个平台上，几乎没有什么难度。谁将是生态系统的掌控者？若干个超级App，像微信、QQ、支付宝这样的。它们不但包装自家的应用，其它开发者也可以把自己的应用放在这个包装里面，借重超级App的广泛覆盖度，抵达最终用户。前文提到了，如果微信小程序获得成功，腾讯必然会重拾Q+的野心，把QQ变成桌面上各种H5应用的App Store。</p>
<p>如果真的会这样，微软岂不是会比Intel还着急？拜托，微软已经不是二十年前主要靠卖Windows和Office的光盘赚钱的那家公司了，未来它会专注于云计算[106]。但Intel还和二十年前一样在卖芯片。</p>
<p>第二是编译技术尤其是虚拟机的发展。如今的编程语言太多了，80年代那种搞定C语言编译器就OK的好日子早已过去。任何一个新CPU架构要想在移动、桌面、服务器市场站稳脚跟，都得搞定无数的编译器（包括虚拟机用的JIT编译器），这是个坏消息。但好消息是，搞定这些编译器基本就差不多了，不用劝说开发者重写汇编代码。</p>
<p>老一代程序员对x86处理器架构和汇编都非常熟悉。求伯君当年开发WPS时，手写几十万行汇编[107]；雷军读本科时，是系里20多年来拿过《汇编语言程序设计》满分成绩的两个学生之一[108]；梁肇新开发超级解霸时，把MMX汇编玩得出神入化。感兴趣的读者可以看看梁的《编程高手箴言》[109]，那里面，描绘了一个对现在的程序员而言，完全陌生的世界。在那个世界里，你开发的PC应用程序想要移植到Mac平台上，几乎要完全重写。</p>
<p>如今高层次的编程语言接管了一切，汇编语言从很多学校的本科课程里消失了，入门教材也从C改成了Java，甚至是Javascript或Python。程序员完全不熟悉底层的CPU。即使是真的需要拼性能的场合，编译器也在很大程度上代替了手写汇编。ARM的工程师告诉我说，ARM在开发开源的Compute Library过程中，主要依靠在C源码中加入标注来指导编译器生成SIMD指令，而不是像梁肇新那样手写。</p>
<p>在这种情况下，软件平台厂商就变得非常强势，因为他们知道，应用开发商只需付出重新编译一遍的代价。比如苹果，就要求所有的App都改为64位的[110]。这样，未来苹果在手机CPU里放弃对32位应用的支持时，甚至都不会有人感觉得到。这对于x86生态系统而言，简直是天方夜谭，显然微软对此非常眼馋，并且尝试在Windows 10 S中复制这种掌控力[111]。</p>
<p>至于谷歌，Android把所有应用都跑在虚拟机上的尝试虽然失败了，但如果未来它再针对AR/VR、AI或机器人发布一个什么软件平台的话，就很有可能完全禁止原生程序。</p>
<p>而Oracle，正在努力开发可以支持所有编程语言、能把所有CPU给OTT掉的全新VM：GraalVM。我们拭目以待。</p>
<p>第三是Emulation技术的发展。虽然眼下ARM阵营中靠Emulation进攻Intel的先锋是高通，但最可怕的选手其实是NVidia。NVidia拥有最厉害的Emulation技术，而且江湖传言Denver处理器的初衷就是针对x86的[113]。当初NVidia的Tegra处理器曾被拿来做Windows 8 RT的二合一平板[114]。如今Denver处理器跑Windows 10绝不会让人意外，那么它会怎么跑呢？肯定是直接在底层硬件上做x86的Emulation，而不是在Emulate出来的ARM指令集上再做一层Eumulation。</p>
<p>Denver处理器前些年没有跳出来抢Intel的饭碗，很大程度上是因为NVidia还在做Intel平台的主板芯片组，另外NVidia还没有那么强大。如今NVidia也不做芯片组生意了，还借AI的东风，股价扶摇直上。说不定哪天，NVidia就会放出Denver处理器的x86 Emulator，做到单线程性能不输Xeon，强攻服务器市场。想想看，在单芯片上集成GPU和x86版的Denver，云计算厂商能不动心？</p>
<p>如果未来Emulation技术进一步发展并且被越来越多的厂商掌握，很可能会出现这种情况：CPU本身是某种外界不了解的指令集，官方发布时，只能Emulate某种开放的指令集，例如RISCV；但是用户可以给它安装不同的Emulator，让它变成x86-64处理器，或者ARM64处理器。在软件定义一切的时代，这并不是多么疯狂的想象。</p>
<p>总之，CPU依然不可或缺，但CPU用谁家的，是什么指令集，会越来越不重要。软件的发展，会在用户和底层的CPU之间加入足够大的缓冲带，CPU的差异，越来越难以被用户察觉到。</p>
<p>展望：让CPU不再难<br>此文在最后修改之时，看到了梁宁的文章《一段关于国产芯片和操作系统的往事》，里面写到：“就像10多年前一样，只要搞定知识产权问题，选择技术路线，找会干的人，投入干，CPU／芯片就能够做出来。搞不定的依然是操作系统。差距大的依然是生态。当年，绕得过Intel，跨不过微软。如今，绕得过Arm，做不出安卓。” 我也曾参与过国产CPU的研发（但不是梁宁提到的方舟），生态之难体会颇深，真的，只是烧钱做芯片，无论烧多少都无法挑战Intel和ARM，何况过去二十年真的没烧多少。</p>
<p>但我并没有梁宁那么悲观，毕竟技术的潮流无法抗拒，借用马化腾的一句名言“可能你什么错都没有，最后就是错在自己太老了”。</p>
<p>Intel和ARM如此强大而且极少犯错，我们如此弱小就算它们犯错也无法利用——但我们可以欺负它们的“老”。</p>
<p>在此借新智元的宝地，向小马哥呼吁一声：</p>
<p>请借助腾讯的强大生态，把CPU和OS这两个老大难问题给OTT掉吧！</p>
<p>做法非常简单，把Q+桌面再重新搞起来，做一款完全使用Javascript&amp;Webassembly编程的操作系统，里面用腾讯文档来替代Office，各种微信小程序都支持起来，适当支持游戏（但要加入家长监控系统）。补贴芯片厂，让它们使用ARM或RISC-V外加国产Imagination gpu做SoC，生产类似Surface这样的二合一平板。底层CPU使用的ISA完全不可见，上层编程完全用H5。这样，就帮祖国把CPU和OS这两个陈年大洞都补上了。</p>
<p>芯片要下苦功，别凡事都指望模式创新。这不假。但偏偏CPU真的面临一个十倍速变革的机会，真的有靠模式创新而胜出的机会，为什么不试试呢？如果腾讯不去尝试一下，谁还有资格呢？促进祖国的微电子发展功德无量，相信这次不会有人说腾讯垄断之类的闲话。</p>
<p>一些参考资料：<br><a href="http://www.cpushack.com/CPU/cpu4.html" target="_blank" rel="noopener">http://www.cpushack.com/CPU/cpu4.html</a><br><a href="https://sec.ch9.ms/ch9/77bc/0cb602d9-0828-49f9-a291-c17b26c377bc/P4171_high.mp4" target="_blank" rel="noopener">https://sec.ch9.ms/ch9/77bc/0cb602d9-0828-49f9-a291-c17b26c377bc/P4171_high.mp4</a><br>(转载自：<a href="https://www.jianshu.com/p/1ac347d0420b?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">https://www.jianshu.com/p/1ac347d0420b?from=timeline&amp;isappinstalled=0</a> ）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/IT/">IT</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/芯片/">芯片</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-一张图让你了解编程语言发展史" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/21/一张图让你了解编程语言发展史/" class="article-date">
      <time datetime="2018-04-21T14:02:12.000Z" itemprop="datePublished">2018-04-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/21/一张图让你了解编程语言发展史/">一张图让你了解编程语言发展史</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>我们都知道，编程语言是一组用来定义计算机程序的语法规则。它是一种被标准化的交流语言，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。尽管人们多次试图创造一种通用的程序设计语言，却没有一次尝试是成功的。之所以有那么多种不同的编程语言存在的原因是设计程序语言的初衷不同，对语言学习曲线的追求不同，不同程序之间的运行成本差异等。</p>
<p>下面这张图片描绘了整个编程语言的历史。包括各种编程语言的发明人，编程语言的特点和适用领域，被什么网站或公司使用等。</p>
<p><img src="/images/132.jpg" alt="&quot;language”"></p>
<p>编程语言的历史早于真正意义的计算机的出现。19世纪就有’可编程的’织布机和钢琴弹奏装置出现，它们都是领域特定语言(DSL)的样例。</p>
<p>编程语言发展的编年史</p>
<p>我们一个统计出来256种编程语言，当然，这么多的语言中只有一些是常用的或实用的。</p>
<p>1951 – Regional Assembly Language<br>1952 – Autocode<br>1954 – IPL (LISP语言的祖先)<br>1955 – FLOW-MATIC (COBOL语言的祖先)<br>1957 – FORTRAN (第一个编译型语言)<br>1957 – COMTRAN (COBOL语言的祖先)<br>1958 – LISP<br>1958 – ALGOL 58<br>1959 – FACT (COBOL语言的祖先)<br>1959 – COBOL<br>1959 – RPG<br>1962 – APL<br>1962 – Simula<br>1962 – SNOBOL<br>1963 – CPL (C语言的祖先)<br>1964 – BASIC<br>1964 – PL/I<br>1966 – JOSS<br>1967 – BCPL (C语言的祖先)<br>1968 – Logo<br>1969 – B (C语言的祖先)<br>1970 – Pascal<br>1970 – Forth<br>1972 – C<br>1972 – Smalltalk<br>1972 – Prolog<br>1973 – ML<br>1975 – Scheme<br>1978 – SQL<br>1980 – C++ (既有类的C语言，更名于1983年7月)<br>1983 – Ada<br>1984 – Common Lisp<br>1984 – MATLAB<br>1985 – Eiffel<br>1986 – Objective-C<br>1986 – Erlang<br>1987 – Perl<br>1988 – Tcl<br>1988 – Mathematica<br>1989 – FL<br>1990 – Haskell<br>1991 – Python<br>1991 – Visual Basic<br>1993 – Ruby<br>1993 – Lua<br>1994 – CLOS (ANSI Common Lisp的一部分)<br>1995 – Java<br>1995 – Delphi (Object Pascal)<br>1995 – JavaScript<br>1995 – PHP<br>1996 – WebDNA<br>1997 – Rebol<br>1999 – D<br>2000 – ActionScript<br>2001 – C#<br>2001 – Visual Basic .NET<br>2002 – F#<br>2003 – Groovy<br>2003 – Scala<br>2007 – Clojure<br>2009 – Go<br>2011 – Dart</p>
<p>从1951年2014年，人类一共发明了256种编程语言，每一种语言的出现都带有某些新特征。编程语言不断的在革新，很快就会有超出这个清单的新编程语言出现</p>
<p>1801 - Joseph Marie Jacquard用打孔卡为一台织布机编写指令，在挂毯上织出了“hello, world”字样。当时的reddit网友对这项工作的反响并不热烈，因为它既缺少尾递归调用，又不支持并发，而且甚至都没有注意在拼写时恰当地区分大小写。</p>
<p>Jacquard织布机是第一台可进行程序控制的织布机。用打孔卡进行编程的概念，直到电子计算机被发明出来之后仍然被广泛运用。</p>
<p>最早的Hello World程序（出自K&amp;R C）打印的是全小写的字符串：’hello, world’。</p>
<p>在许多英文技术社区里，不正确地使用大小写发贴会被视作是小白的行为。（如把“Python”拼作“python”，把“FreeBSD”拼作“freebsd”，把“Qt”拼作“QT”）</p>
<p>1842 - Ada Lovelace写了世界上第一个程序。她的努力只遇到了一点点小小的麻烦，那就是：实际上并没有任何计算机能够用来运行她的程序。后来的企业架构师们重新吸收了她的这个技能，用来学习如何更好地使用UML进行编程。</p>
<p>Ada Lovelace为Charles Babbage的分析机写了一个计算伯努利数的算法实现，因此被后世公认为是世界上第一个程序员。实际上，分析机由于其设计思想过于先进，在当时根本没有 被制造出来。（Babbage的分析机一般被认为是现代电子通用计算机的先驱）</p>
<p>讽刺现在的某些“软件架构师”顶多只会纸上谈兵地画画UML。</p>
<p>1936 - Alan Turing发明了世间一切程序语言的最终形态，但很快他就被英国军情六处“请”去当007了，以至于他根本来不及为这些语言申请专利。</p>
<p>与通用图灵机（Universal Turing machine）等价的语言被称为图灵完备的（Turing completeness），它定义了“什么样的语言可以被称作是程序语言”。</p>
<p>二战期间Turing曾秘密地为英国军方工作，破解德军的Enigma密码机，并在战后被授予大英帝国勋章。但这项事实直到多年以后才向公众公开。</p>
<p>1936 - Alonzo Church同时也发明了世间一切程序语言的最终形态，甚至做得更好。但他的λ演算被绝大部分人忽视了，因为它与C语言“不够像”。尽管存在着这样的批评，但事实上，C在当时还没有被发明出来。</p>
<p>Church是Turing在Princeton的博士生导师，他在λ演算方面的工作先于Turing指出了不存在一个对可判定性问题的通用解法，这后来证明和Turing针对停机问题提出的图灵机模型是等价的。即著名的Church-Turing论题。</p>
<p>说Church“甚至做得更好”，因为λ演算为后世所有的函数式语言提供了理论基础。</p>
<p>现在一种常见的关于函数式编程的批评就是：“它们与C语言不够像”。</p>
<p>1940年代 - 一些直接采用布线和开关来进行程序控制的“计算机”出现了。工程师们当时这么做，据说是为了避开“用空格还是用制表符缩进”这样的论战。</p>
<p>据说当时负责设计ENIAC的工程师中间曾经发生过这样的争论：</p>
<p>空格比制表符好。</p>
<p>制表符比空格好。</p>
<p>4个空格比8个空格好。</p>
<p>什么？用2个空格的统统烧死。</p>
<p>关于这台具有里程碑意义的人类史上第一台电子计算机ENIAC上应该预装何种编辑器，工程师们还发生过这样的争吵：</p>
<p>Vim比Emacs好！</p>
<p>Emacs比Vim好！</p>
<p>强烈推荐Sublime Text。</p>
<p>你丫用编辑器的都是找虐，IDE才是王道。</p>
<p>没错，要用就用世界上最好的公司微软开发出来的世界上最好的IDE：Visual Studio。</p>
<p>我早就看透了无谓的编辑器论战什么的了，我要告诉楼上吵架的，你们全都是傻逼！</p>
<p>最后，工程师们一致决定使用布线和开关来为他们即将发明的计算机进行编程，机智地避开了所有这些无谓的争吵，最终齐心协力创造出了人类历史上第一台电子计算机：ENIAC。</p>
<p><img src="/images/134.jpg" alt="&quot;language”"></p>
<p>（图：两位ENIAC程序员在运用敏捷开发方法进行愉快的结对编程。“自从抛弃伴随我多年的Emacs和HHKB Pro、改用布线和开关进行编程之后，我的左手小指麻痹奇迹般地痊愈了。”其中一位接受采访时如是说。另一位则表示：“新的编程方式让曾经专注颈椎病20 年的我得到了彻底的康复，不用再整天盯着显示屏，身心同时得到了极大的放松，值得大力推广！”）</p>
<p>1957 - John Backus和IBM发明了FORTRAN语言。关于IBM或FORTRAN并没有什么特别好笑的地方。除了，写FORTRAN程序的时候不系蓝领带将被编译器视作是一个syntax error。</p>
<p>蓝领带、白衬衫、深色西装似乎是IBM公司20世纪经典的dress code。</p>
<p>早期FORTRAN（FORTRAN 77）对程序书写格式的要求那是相当严格。（例如，蛋疼的固定格式缩进）</p>
<p>1958 - John McCarthy和Paul Graham发明了LISP。由于冷战期间的战略括号资源储备所造成的巨大成本，LISP从未流行过。尽管欠缺足够的流行度，LISP（现在叫做 “Lisp”，有时叫“Arc”）仍然被视作一门有影响力的语言，在关键的算法思想诸如递归（recursion）和提升逼格 （condescension）上尤为典范。</p>
<p>LISP发明的那一年Paul Graham其实还没有出生。据说是因为某本叫做《Haste and Waste》的伪程装黑圣典实在太有名了，以至于许多编程小白们把写这本书的传奇人物同Lisp之间画上了等号。</p>
<p>提升逼格确实是一种与递归调用同样关键的算法思想。嗯，你懂的。</p>
<p>1959 - 在输掉了和L. Ron Hubbard之间的一场打赌之后，Grace Hopper和其他几个抖S发明了所谓的“面向Boilerplate的全大写化语言（Capitalization Of Boilerplate Oriented Language，COBOL）”。多年以后，由于一些被误导的、性别歧视主义者对Adm. Hopper关于COBOL的工作的报复，在Ruby技术会议上不时会看到一些厌女主义乃至仇视女性的材料出现。</p>
<p>L. Ron Hubbard是山达基教（Scientology）的创始人，二战期间曾与Grace Hopper同样供职于美国海军。（尚不清楚这两人之间有无其他联系）</p>
<p>COBOL语言以代码极其冗长和通篇大写字母的书写风格而闻名。</p>
<p>Adm. Hopper：Grace Murray Hopper女士的军衔是Rear Admiral Lower Half，即美国海军准将。</p>
<p>1964 - John Kemeny和Thomas Kurtz创造了BASIC，一个为非计算机科学家设计的非结构化的程序语言。</p>
<p>1965 - Kemeny和Kurtz两人goto到了1964。</p>
<p>调侃BASIC语言对行号和goto的无节制滥用。</p>
<p>1970 - Guy Steele和Gerald Sussman创造了Scheme。他们的工作导致了一系列以《Lambda之究极（Lambda the Ultimate）……》为标题开头的论文发表，并在《Lambda之究极厨房神器》这一篇中达到了最高潮。以这篇论文为基础，开始了一个长年累月的、收 视率究极失败的晚间电视购物节目。Lambda们因为其概念相对难以理解而被大众所忽视，直到未来的某一天，Java语言终于让它们变得有名了起来。通过 不包含它们这件事情。</p>
<p>1970 - Niklaus Wirth创造了Pascal，一个过程式的语言。很快就有人开始声讨Pascal，因为它使用了类似“x := x + y”这样的语法，而不是更为人熟知的类C语法“x = x + y”。尽管存在着这样的批评，而事实上当时C还没有被发明出来。</p>
<p>1972 - Dennis Ritchie发明了一把射击时能同时向前和向后两个方向发射子弹的绝世好枪。但他对此发明造成的致死和终身残疾数量感到还不够满意，所以他又发明了C语言和Unix。</p>
<p>翻译君：……</p>
<p>1972 - Alain Colmerauer设计了逻辑编程语言Prolog。他的目标是创造一个具有两岁小孩智商的程序语言。为了证明他成功达到了这个目标，他展示了一个Prolog程序，它对于每条查询都会机智地给出相同的回答：“No”。</p>
<p>1973 - Robin Milner创造了ML，一个建立在M&amp;M类型理论基础上的语言。由ML衍生而来的SML加上了一套形式语义的规范。当被要求给这个形式语义本身 书写一套形式语义时，Milner的脑子爆掉了。其他ML家族的著名语言还包括OCaml，F#，和，Visual Basic。</p>
<p>1980 - Alan Kay创造了Smalltalk并发明了“面向对象”这个词。当被问到它的含义时，他回答道：“Smalltalk程序本身就是对象。”当被问到对象是由 什么组成时，他回答到：“对象。”当再一次被问到这个问题时，他说“看，它从里到外都是对象。直到你抽出一只乌龟。”</p>
<p>Smalltalk的设计从很大程度上受到了Logo的影响。</p>
<p>1983 - 为了纪念伟大的先辈程序员Ada Lovelace那能够写出永远也无法被执行的代码的彪悍技能，Jean Ichbiah和美国国防部创造了Ada语言。尽管缺乏证据显示有任何重要的Ada程序曾经被完成过，历史学家仍然确信Ada是个成功的公益项目，它让数 以千计的国防承包商免于沦落为与黑帮为伍。</p>
<p>Ada曾经是美国国防部指定的嵌入式计算机系统唯一开发语言，在其研发上耗资巨大。（国防承包商们于是不用靠贩卖军火给黑帮来维持生计了）</p>
<p>虽然有充分的证据显示Ada的整型范围溢出检查失败导致弄坏了欧空局的一枚Ariane 5运载火箭，不过美国国防部发言人对此表示：关我P事。</p>
<p>1983 - Bjarne Stroustrup把他所听说过的一切都试图嫁接到C上，创造出了C++。最后得到的语言是如此地复杂，以至于程序必须被送到未来去让“天网”人工智能 进行编译。编译时间难以容忍。天网开展这项服务的动机仍然不为人知，但来自未来的发言人说道：“没什么好担心的，宝贝。”带着一口奥地利腔的机械口音。有 一些来自坊间的推测，所谓的天网只不过是个自命不凡的缓冲区溢出而已。</p>
<p>1986 - Brad Cox和Tom Love创造了Objective-C，宣称“该语言完美地结合了C的内存安全性与Smalltalk的神奇效率”。现在的历史学家怀疑这两人其实是诵读障碍症患者。</p>
<p>“C的内存安全性十分好”。</p>
<p>Smalltalk编译出来的程序以低效缓慢著称。</p>
<p>1987 - Larry Wall在电脑前打了个盹，Larry Wall的脑门子压到了键盘上。醒来之后，Larry Wall深信 ，在Larry Wall的显示器上出现的神秘字符串并非是随机的，那是某种编程语言之程序样例的神谕。那必是上帝要他的先知，Larry Wall，去设计的。Perl语言就此诞生了。</p>
<p>1990 - 一个由Simon Peyton-Jones、Paul Hudak、Philip Wadler、Ashton Kutcher和善待动物组织（PETA）组成的委员会创造了Haskell，一种纯函数式的、非严求值的语言。Haskell由于使用了Monad这种 较费解的概念来控制副作用而遭到了一些批评意见。Wadler试图平息这些质疑，他解释说：“一个单子（Monad）说白了不过就是自函子范畴上的一个幺 半群而已，这有什么难以理解的？”</p>
<p>1991 - 荷兰程序员Guido van Rossum为了一次神秘的手术而进行了一次阿根廷之旅。回来后他带着一个巨大的颅疤，发明了Python，而被数以军团计的追随者们加冕为“终生大独裁 者”，并向全世界宣布“要办到一件事情，只可有唯一的一种方法！”。整个波兰陷入了恐慌。</p>
<p>BDFL（Benevolent Dictator for Life）：开源社区一种流行的说法，“仁慈的”终生大独裁者。这个说法最早指的就是Guido van Rossum。</p>
<p>希特勒在提出建立“纯正的雅利安人国家”“统一的大德意志帝国”并实现了德奥合并之后，翌年便入侵了波兰，引发了第二次世界大战。“我一个人征服了整个欧洲！”（感觉好棒好棒的）</p>
<p>1995 - 在家门口附近的一个意大利饭馆用餐时，Rasmus Lerdorf意识到他吃的那盘意面正好是一个用来理解WWW万维网的极好模型，而所有的Web应用都应该仿照它们的媒介那样去做。在他的餐巾的背后，他 设计出了著名的“可编程超链接Pasta（Programmable Hyperlinked Pasta，PHP）”语言。PHP的文档至今仍然保留在那片餐巾上。</p>
<p>PHP最显著的特点就是：代码是可以直接嵌在HTML文档中的。</p>
<p>1995 - 松本“Mad Matz”行弘创造出了Ruby语言，用来辟谣一些意味不明的、有关澳洲将会变成一片由莫霍克族战士和Tina Turner统治的荒漠的末世预言。该语言后来被它的真正发明者David Heinemeier Hansson重新命名为Ruby on Rails。（关于某个叫松本行弘的人发明了一种叫做Ruby的语言这件事情从未发生过，最好在这篇文章的下一个版本中删掉。 - DHH表示）</p>
<p>最早关于Ruby的国际会议不是RubyConf，而是每年在澳大利亚举办的OSDConf。</p>
<p>这里应该是在吐槽Ruby的杀手级应用Ruby on Rails实在太有名了，以至于超越了原来的Ruby语言本身。</p>
<p>Matz并没有为“Ruby”这个名字注册商标——本着开源的黑客精神。</p>
<p>而DHH（RoR的作者）却把“Ruby on Rails”这个（包含了“Ruby”字样的）名称注册成了商标，并且阻止别人未经授权使用“Rails”这个名字。</p>
<p>1995 - Brendan Eich读完了历史上所有在程序语言设计中曾经出现过的错误，自己又发明了一些更多的错误，然后用它们创造出了LiveScript。之后，为了紧跟 Java语言的时髦潮流，它被重新命名为JavaScript。再然后，为了追随一种皮肤病的时髦潮流，这语言又被命名为ECMAScript。</p>
<p>1996 - James Gosling发明了Java。Java是一个相对繁冗的、带垃圾收集的、基于类的、静态类型的、单分派的面向对象语言，拥有单实现继承和多接口继承。Sun不遗余力地宣传着Java的独一无二不同凡响之处。</p>
<p>2001 - Anders Hejlsberg发明了C#。C#是一个相对繁冗的、带垃圾收集的、基于类的、静态类型的、单分派的面向对象语言，拥有单实现继承和多接口继承。微软不遗余力地宣传着C#的独一无二不同凡响之处。</p>
<p>2003 - 一个叫Martin Odersky的醉汉看见了好时瑞森花生酱杯的广告，展示了某个人的花生酱倒入另一个人的巧克力的场景，他忽然有了个点子。他创造了Scala，一种结合 了面向对象和函数式编程的语言。这同时激怒了两个阵营的忠实信徒，他们立刻宣布要发动圣战烧死异教徒。</p>
<p>(素材来自：<a href="https://mp.weixin.qq.com/s/A9inMUEDuygIFW9lPMCARQ?）" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/A9inMUEDuygIFW9lPMCARQ?）</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/编程语言/">编程语言</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 葆宁
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>